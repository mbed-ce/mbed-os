<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: SerialBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmbed_1_1_serial_base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">SerialBase Class Reference<div class="ingroups"><a class="el" href="group__mbed-os-public.html">Public API</a> &raquo; <a class="el" href="group__drivers-public-api.html">Drivers</a> &raquo; <a class="el" href="group__drivers-public-api-uart.html">UART</a> &raquo; <a class="el" href="group__drivers___serial_base.html">SerialBase class</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A base class for serial port implementations Can't be instantiated directly (use <a class="el" href="classmbed_1_1_unbuffered_serial.html" title="Class implementation for unbuffered I/O for an interrupt driven application or one that needs to have...">UnbufferedSerial</a> or <a class="el" href="classmbed_1_1_buffered_serial.html" title="Class providing buffered UART communication functionality using separate circular buffer for send and...">BufferedSerial</a>)  
 <a href="classmbed_1_1_serial_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_serial_base_8h_source.html">SerialBase.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SerialBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmbed_1_1_serial_base.png" usemap="#SerialBase_map" alt=""/>
  <map id="SerialBase_map" name="SerialBase_map">
<area href="classmbed_1_1_non_copyable.html" alt="NonCopyable&lt; SerialBase &gt;" shape="rect" coords="92,0,266,24"/>
<area href="classmbed_1_1_buffered_serial.html" title="Class providing buffered UART communication functionality using separate circular buffer for send and..." alt="BufferedSerial" shape="rect" coords="0,112,174,136"/>
<area href="classmbed_1_1_unbuffered_serial.html" title="Class implementation for unbuffered I/O for an interrupt driven application or one that needs to have..." alt="UnbufferedSerial" shape="rect" coords="184,112,358,136"/>
<area href="class_e_m_w3080_b___u_a_r_t.html" alt="EMW3080B_UART" shape="rect" coords="0,168,174,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab9b7cb38488f1159d8eed3ffdb2ae314" id="r_ab9b7cb38488f1159d8eed3ffdb2ae314"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#ab9b7cb38488f1159d8eed3ffdb2ae314">Flow</a> {  }</td></tr>
<tr class="separator:ab9b7cb38488f1159d8eed3ffdb2ae314"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9afb7aa9321cd71a8a26a673157583d2" id="r_a9afb7aa9321cd71a8a26a673157583d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a9afb7aa9321cd71a8a26a673157583d2">baud</a> (int baudrate)</td></tr>
<tr class="memdesc:a9afb7aa9321cd71a8a26a673157583d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the baud rate of the serial port.  <br /></td></tr>
<tr class="separator:a9afb7aa9321cd71a8a26a673157583d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8274461aa9a0611c28c4c6aeae665277" id="r_a8274461aa9a0611c28c4c6aeae665277"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a8274461aa9a0611c28c4c6aeae665277">format</a> (int bits=8, Parity parity=SerialBase::None, int stop_bits=1)</td></tr>
<tr class="memdesc:a8274461aa9a0611c28c4c6aeae665277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transmission format used by the serial port.  <br /></td></tr>
<tr class="separator:a8274461aa9a0611c28c4c6aeae665277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54635d8d9d55acd3e8426767271e9d7b" id="r_a54635d8d9d55acd3e8426767271e9d7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a54635d8d9d55acd3e8426767271e9d7b">readable</a> ()</td></tr>
<tr class="memdesc:a54635d8d9d55acd3e8426767271e9d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if there is a character available to read.  <br /></td></tr>
<tr class="separator:a54635d8d9d55acd3e8426767271e9d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb16b1f54af7224f26f865ab9b7dd86" id="r_a9bb16b1f54af7224f26f865ab9b7dd86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a9bb16b1f54af7224f26f865ab9b7dd86">writeable</a> ()</td></tr>
<tr class="memdesc:a9bb16b1f54af7224f26f865ab9b7dd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if there is space available to write a character.  <br /></td></tr>
<tr class="separator:a9bb16b1f54af7224f26f865ab9b7dd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554dccfc95f8e864de7be65a4a793e98" id="r_a554dccfc95f8e864de7be65a4a793e98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a554dccfc95f8e864de7be65a4a793e98">attach</a> (<a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void()&gt; func, IrqType type=RxIrq)</td></tr>
<tr class="memdesc:a554dccfc95f8e864de7be65a4a793e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a function to call whenever a serial interrupt is generated.  <br /></td></tr>
<tr class="separator:a554dccfc95f8e864de7be65a4a793e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8509410439be6477d7532b0ccec15c" id="r_a2b8509410439be6477d7532b0ccec15c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a2b8509410439be6477d7532b0ccec15c">set_break</a> ()</td></tr>
<tr class="memdesc:a2b8509410439be6477d7532b0ccec15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a break condition on the serial line NOTE: Clear break needs to run at least one frame after set_break is called.  <br /></td></tr>
<tr class="separator:a2b8509410439be6477d7532b0ccec15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd03a9e8b635c5fb87247a08758f62" id="r_ab0dd03a9e8b635c5fb87247a08758f62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#ab0dd03a9e8b635c5fb87247a08758f62">clear_break</a> ()</td></tr>
<tr class="memdesc:ab0dd03a9e8b635c5fb87247a08758f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a break condition on the serial line NOTE: Should be run at least one frame after set_break is called.  <br /></td></tr>
<tr class="separator:ab0dd03a9e8b635c5fb87247a08758f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fca2a71c423b8e004c4abf6dc367fc2" id="r_a7fca2a71c423b8e004c4abf6dc367fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a7fca2a71c423b8e004c4abf6dc367fc2">send_break</a> ()</td></tr>
<tr class="memdesc:a7fca2a71c423b8e004c4abf6dc367fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a break condition on the serial line.  <br /></td></tr>
<tr class="separator:a7fca2a71c423b8e004c4abf6dc367fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e2859a5a286eb5734dafc11f7b0419" id="r_ad8e2859a5a286eb5734dafc11f7b0419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#ad8e2859a5a286eb5734dafc11f7b0419">enable_input</a> (bool enable=true)</td></tr>
<tr class="memdesc:ad8e2859a5a286eb5734dafc11f7b0419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable serial input.  <br /></td></tr>
<tr class="separator:ad8e2859a5a286eb5734dafc11f7b0419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e17c37d672d9e141d3719864d9ac7d" id="r_a97e17c37d672d9e141d3719864d9ac7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a97e17c37d672d9e141d3719864d9ac7d">enable_output</a> (bool enable=true)</td></tr>
<tr class="memdesc:a97e17c37d672d9e141d3719864d9ac7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable serial output.  <br /></td></tr>
<tr class="separator:a97e17c37d672d9e141d3719864d9ac7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a82a55bc262aa9ed7d2e1a16419389" id="r_a68a82a55bc262aa9ed7d2e1a16419389"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a68a82a55bc262aa9ed7d2e1a16419389">set_flow_control</a> (<a class="el" href="classmbed_1_1_serial_base.html#ab9b7cb38488f1159d8eed3ffdb2ae314">Flow</a> type, PinName flow1=NC, PinName flow2=NC)</td></tr>
<tr class="memdesc:a68a82a55bc262aa9ed7d2e1a16419389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flow control type on the serial port.  <br /></td></tr>
<tr class="separator:a68a82a55bc262aa9ed7d2e1a16419389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2caa378a586dbf0bf38c5c778dbb44b" id="r_af2caa378a586dbf0bf38c5c778dbb44b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#af2caa378a586dbf0bf38c5c778dbb44b">set_flow_control</a> (<a class="el" href="classmbed_1_1_serial_base.html#ab9b7cb38488f1159d8eed3ffdb2ae314">Flow</a> type, const <a class="el" href="structserial__fc__pinmap__t.html">serial_fc_pinmap_t</a> &amp;static_pinmap)</td></tr>
<tr class="memdesc:af2caa378a586dbf0bf38c5c778dbb44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flow control type on the serial port.  <br /></td></tr>
<tr class="separator:af2caa378a586dbf0bf38c5c778dbb44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3f9366101e9d01349d7bccb830d9ee" id="r_a7b3f9366101e9d01349d7bccb830d9ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a7b3f9366101e9d01349d7bccb830d9ee">write</a> (const uint8_t *buffer, int length, const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;<a class="el" href="group__platform___callback.html#ga90e30db9c535d448cd949f7f55bb8f31">callback</a>, int event=SERIAL_EVENT_TX_COMPLETE)</td></tr>
<tr class="memdesc:a7b3f9366101e9d01349d7bccb830d9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin asynchronous write using 8bit buffer.  <br /></td></tr>
<tr class="separator:a7b3f9366101e9d01349d7bccb830d9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fdcc8764bf2e44109793ea9d7b47dd" id="r_a93fdcc8764bf2e44109793ea9d7b47dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a93fdcc8764bf2e44109793ea9d7b47dd">write</a> (const uint16_t *buffer, int length, const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;<a class="el" href="group__platform___callback.html#ga90e30db9c535d448cd949f7f55bb8f31">callback</a>, int event=SERIAL_EVENT_TX_COMPLETE)</td></tr>
<tr class="memdesc:a93fdcc8764bf2e44109793ea9d7b47dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin asynchronous write using 16bit buffer.  <br /></td></tr>
<tr class="separator:a93fdcc8764bf2e44109793ea9d7b47dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859436a72de08d7e4eb127e11ca4b609" id="r_a859436a72de08d7e4eb127e11ca4b609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a859436a72de08d7e4eb127e11ca4b609">abort_write</a> ()</td></tr>
<tr class="memdesc:a859436a72de08d7e4eb127e11ca4b609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the on-going write transfer.  <br /></td></tr>
<tr class="separator:a859436a72de08d7e4eb127e11ca4b609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335c17fdb4ad3c94595b5cfe5496a7c7" id="r_a335c17fdb4ad3c94595b5cfe5496a7c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a335c17fdb4ad3c94595b5cfe5496a7c7">read</a> (uint8_t *buffer, int length, const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;<a class="el" href="group__platform___callback.html#ga90e30db9c535d448cd949f7f55bb8f31">callback</a>, int event=SERIAL_EVENT_RX_COMPLETE, unsigned char char_match=SERIAL_RESERVED_CHAR_MATCH)</td></tr>
<tr class="memdesc:a335c17fdb4ad3c94595b5cfe5496a7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin asynchronous reading using 8bit buffer.  <br /></td></tr>
<tr class="separator:a335c17fdb4ad3c94595b5cfe5496a7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebd1e506e3a8abd2e193dbe159fa87f" id="r_a1ebd1e506e3a8abd2e193dbe159fa87f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a1ebd1e506e3a8abd2e193dbe159fa87f">read</a> (uint16_t *buffer, int length, const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;<a class="el" href="group__platform___callback.html#ga90e30db9c535d448cd949f7f55bb8f31">callback</a>, int event=SERIAL_EVENT_RX_COMPLETE, unsigned char char_match=SERIAL_RESERVED_CHAR_MATCH)</td></tr>
<tr class="memdesc:a1ebd1e506e3a8abd2e193dbe159fa87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin asynchronous reading using 16bit buffer.  <br /></td></tr>
<tr class="separator:a1ebd1e506e3a8abd2e193dbe159fa87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444087f07f1d2dac9f688e3891054893" id="r_a444087f07f1d2dac9f688e3891054893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a444087f07f1d2dac9f688e3891054893">abort_read</a> ()</td></tr>
<tr class="memdesc:a444087f07f1d2dac9f688e3891054893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the on-going read transfer.  <br /></td></tr>
<tr class="separator:a444087f07f1d2dac9f688e3891054893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6c7090d9340149fb1979310baf9ef9" id="r_aac6c7090d9340149fb1979310baf9ef9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#aac6c7090d9340149fb1979310baf9ef9">set_dma_usage_tx</a> (<a class="el" href="group__hal.html#ga9fb5be593465bb507b7bc23945ddf30c">DMAUsage</a> usage)</td></tr>
<tr class="memdesc:aac6c7090d9340149fb1979310baf9ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DMA usage suggestion for non-blocking TX transfers.  <br /></td></tr>
<tr class="separator:aac6c7090d9340149fb1979310baf9ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b50918e727c578a5df2e48c649433a2" id="r_a8b50918e727c578a5df2e48c649433a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_serial_base.html#a8b50918e727c578a5df2e48c649433a2">set_dma_usage_rx</a> (<a class="el" href="group__hal.html#ga9fb5be593465bb507b7bc23945ddf30c">DMAUsage</a> usage)</td></tr>
<tr class="memdesc:a8b50918e727c578a5df2e48c649433a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DMA usage suggestion for non-blocking RX transfers.  <br /></td></tr>
<tr class="separator:a8b50918e727c578a5df2e48c649433a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A base class for serial port implementations Can't be instantiated directly (use <a class="el" href="classmbed_1_1_unbuffered_serial.html" title="Class implementation for unbuffered I/O for an interrupt driven application or one that needs to have...">UnbufferedSerial</a> or <a class="el" href="classmbed_1_1_buffered_serial.html" title="Class providing buffered UART communication functionality using separate circular buffer for send and...">BufferedSerial</a>) </p>
<dl class="section note"><dt>Note</dt><dd>Synchronization level: Set by subclass </dd></dl>

<p class="definition">Definition at line <a class="el" href="_serial_base_8h_source.html#l00046">46</a> of file <a class="el" href="_serial_base_8h_source.html">SerialBase.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab9b7cb38488f1159d8eed3ffdb2ae314" name="ab9b7cb38488f1159d8eed3ffdb2ae314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b7cb38488f1159d8eed3ffdb2ae314">&#9670;&#160;</a></span>Flow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmbed_1_1_serial_base.html#ab9b7cb38488f1159d8eed3ffdb2ae314">Flow</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab9b7cb38488f1159d8eed3ffdb2ae314ae58caa68ff8b6e4838007985c7e3ae66" name="ab9b7cb38488f1159d8eed3ffdb2ae314ae58caa68ff8b6e4838007985c7e3ae66"></a>RTS&#160;</td><td class="fielddoc"><p>RS-232-E RTS flow control. </p>
<p>This is used to prevent the other end of the connection from sending more bytes than the Mbed MCU can process. When this flow control is active, the RTS signal will normally be asserted (low), but will go deasserted (high) if the Mbed MCU might not have Rx buffer space to store another byte. Note that in this configuration the RTS signal actually operates as a "ready to receive" (RTR) output, not a true RTS. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9b7cb38488f1159d8eed3ffdb2ae314a97dc7d7bbe8a217f4bc934b4a868c521" name="ab9b7cb38488f1159d8eed3ffdb2ae314a97dc7d7bbe8a217f4bc934b4a868c521"></a>CTS&#160;</td><td class="fielddoc"><p>RS-232 CTS flow control. </p>
<p>This is used to prevent the Mbed MCU from sending more bytes than the other end of the connection can process. When this flow control is active, the CTS pin will be sampled after transmitting each byte, and if if is deasserted (high), transmission will pause until it becomes asserted (low) again. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9b7cb38488f1159d8eed3ffdb2ae314a43c157dfce9d6c768db7a3dd4943c5b8" name="ab9b7cb38488f1159d8eed3ffdb2ae314a43c157dfce9d6c768db7a3dd4943c5b8"></a>RTSCTS&#160;</td><td class="fielddoc"><p>Combination of RTS and CTS flow control as previously defined. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_serial_base_8h_source.html#l00070">70</a> of file <a class="el" href="_serial_base_8h_source.html">SerialBase.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9afb7aa9321cd71a8a26a673157583d2" name="a9afb7aa9321cd71a8a26a673157583d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afb7aa9321cd71a8a26a673157583d2">&#9670;&#160;</a></span>baud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void baud </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the baud rate of the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The baudrate of the serial port (default = platform.default-serial-baud-rate). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8274461aa9a0611c28c4c6aeae665277" name="a8274461aa9a0611c28c4c6aeae665277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8274461aa9a0611c28c4c6aeae665277">&#9670;&#160;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>parity</em> = <code>SerialBase::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop_bits</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the transmission format used by the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>The number of bits in a word (5-8; default = 8) </td></tr>
    <tr><td class="paramname">parity</td><td>The parity used (SerialBase::None, SerialBase::Odd, SerialBase::Even, SerialBase::Forced1, SerialBase::Forced0; default = SerialBase::None) </td></tr>
    <tr><td class="paramname">stop_bits</td><td>The number of stop bits (1 or 2; default = 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54635d8d9d55acd3e8426767271e9d7b" name="a54635d8d9d55acd3e8426767271e9d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54635d8d9d55acd3e8426767271e9d7b">&#9670;&#160;</a></span>readable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if there is a character available to read. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if there is a character available to read, 0 otherwise </dd></dl>

</div>
</div>
<a id="a9bb16b1f54af7224f26f865ab9b7dd86" name="a9bb16b1f54af7224f26f865ab9b7dd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb16b1f54af7224f26f865ab9b7dd86">&#9670;&#160;</a></span>writeable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if there is space available to write a character. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if there is space to write a character, 0 otherwise </dd></dl>

</div>
</div>
<a id="a554dccfc95f8e864de7be65a4a793e98" name="a554dccfc95f8e864de7be65a4a793e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554dccfc95f8e864de7be65a4a793e98">&#9670;&#160;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IrqType&#160;</td>
          <td class="paramname"><em>type</em> = <code>RxIrq</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a function to call whenever a serial interrupt is generated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A pointer to a void function, or 0 to set as none </td></tr>
    <tr><td class="paramname">type</td><td>Which serial interrupt to attach the member function to (Serial::RxIrq for receive, TxIrq for transmit buffer empty) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b8509410439be6477d7532b0ccec15c" name="a2b8509410439be6477d7532b0ccec15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8509410439be6477d7532b0ccec15c">&#9670;&#160;</a></span>set_break()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_break </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a break condition on the serial line NOTE: Clear break needs to run at least one frame after set_break is called. </p>

</div>
</div>
<a id="ab0dd03a9e8b635c5fb87247a08758f62" name="ab0dd03a9e8b635c5fb87247a08758f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dd03a9e8b635c5fb87247a08758f62">&#9670;&#160;</a></span>clear_break()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_break </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a break condition on the serial line NOTE: Should be run at least one frame after set_break is called. </p>

</div>
</div>
<a id="a7fca2a71c423b8e004c4abf6dc367fc2" name="a7fca2a71c423b8e004c4abf6dc367fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fca2a71c423b8e004c4abf6dc367fc2">&#9670;&#160;</a></span>send_break()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_break </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a break condition on the serial line. </p>

</div>
</div>
<a id="ad8e2859a5a286eb5734dafc11f7b0419" name="ad8e2859a5a286eb5734dafc11f7b0419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e2859a5a286eb5734dafc11f7b0419">&#9670;&#160;</a></span>enable_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enable_input </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable serial input. </p>
<p>If both serial input and serial output are disabled, the peripheral is freed. If either serial input or serial output is re-enabled, the peripheral is reinitialized.</p>
<p>On re-initialization rx interrupts will be enabled if a rx handler is attached. The rx handler is called once during re-initialization. </p>

</div>
</div>
<a id="a97e17c37d672d9e141d3719864d9ac7d" name="a97e17c37d672d9e141d3719864d9ac7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e17c37d672d9e141d3719864d9ac7d">&#9670;&#160;</a></span>enable_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enable_output </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable serial output. </p>
<p>If both serial input and serial output are disabled, the peripheral is freed. If either serial input or serial output is re-enabled, the peripheral is reinitialized.</p>
<p>On re-initialization tx interrupts will be enabled if a tx handler is attached. The tx handler is called once during re-initialization. </p>

</div>
</div>
<a id="a68a82a55bc262aa9ed7d2e1a16419389" name="a68a82a55bc262aa9ed7d2e1a16419389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a82a55bc262aa9ed7d2e1a16419389">&#9670;&#160;</a></span>set_flow_control() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_flow_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_serial_base.html#ab9b7cb38488f1159d8eed3ffdb2ae314">Flow</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>flow1</em> = <code>NC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>flow2</em> = <code>NC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flow control type on the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the flow control type (Disabled, RTS, CTS, RTSCTS) </td></tr>
    <tr><td class="paramname">flow1</td><td>the first flow control pin (RTS for RTS or RTSCTS, CTS for CTS) </td></tr>
    <tr><td class="paramname">flow2</td><td>the second flow control pin (CTS for RTSCTS) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2caa378a586dbf0bf38c5c778dbb44b" name="af2caa378a586dbf0bf38c5c778dbb44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2caa378a586dbf0bf38c5c778dbb44b">&#9670;&#160;</a></span>set_flow_control() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_flow_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_serial_base.html#ab9b7cb38488f1159d8eed3ffdb2ae314">Flow</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structserial__fc__pinmap__t.html">serial_fc_pinmap_t</a> &amp;&#160;</td>
          <td class="paramname"><em>static_pinmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flow control type on the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the flow control type (Disabled, RTS, CTS, RTSCTS) </td></tr>
    <tr><td class="paramname">static_pinmap</td><td>reference to structure which holds static pinmap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b3f9366101e9d01349d7bccb830d9ee" name="a7b3f9366101e9d01349d7bccb830d9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3f9366101e9d01349d7bccb830d9ee">&#9670;&#160;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em> = <code>SERIAL_EVENT_TX_COMPLETE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin asynchronous write using 8bit buffer. </p>
<p>The write operation ends with any of the enabled events and invokes registered callback function (which can be empty to not receive callback at all). Events that are not enabled by event argument are simply ignored. Operation has to be ended explicitly by calling <a class="el" href="classmbed_1_1_serial_base.html#a859436a72de08d7e4eb127e11ca4b609" title="Abort the on-going write transfer.">abort_write()</a> when no events are enabled. This function locks the deep sleep until any event has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer where received data will be stored </td></tr>
    <tr><td class="paramname">length</td><td>The buffer length in bytes </td></tr>
    <tr><td class="paramname">callback</td><td>The event callback function </td></tr>
    <tr><td class="paramname">event</td><td>The logical OR of TX events that should end operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if new transaction was started, -1 if transaction is already on-going </dd></dl>

</div>
</div>
<a id="a93fdcc8764bf2e44109793ea9d7b47dd" name="a93fdcc8764bf2e44109793ea9d7b47dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fdcc8764bf2e44109793ea9d7b47dd">&#9670;&#160;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em> = <code>SERIAL_EVENT_TX_COMPLETE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin asynchronous write using 16bit buffer. </p>
<p>The write operation ends with any of the enabled events and invokes registered callback function (which can be empty to not receive callback at all). Events that are not enabled by event argument are simply ignored. Operation has to be ended explicitly by calling <a class="el" href="classmbed_1_1_serial_base.html#a859436a72de08d7e4eb127e11ca4b609" title="Abort the on-going write transfer.">abort_write()</a> when no events are enabled. This function locks the deep sleep until any event has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer where received data will be stored </td></tr>
    <tr><td class="paramname">length</td><td>The buffer length in bytes </td></tr>
    <tr><td class="paramname">callback</td><td>The event callback function </td></tr>
    <tr><td class="paramname">event</td><td>The logical OR of TX events that should end operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if new transaction was started, -1 if transaction is already on-going </dd></dl>

</div>
</div>
<a id="a859436a72de08d7e4eb127e11ca4b609" name="a859436a72de08d7e4eb127e11ca4b609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859436a72de08d7e4eb127e11ca4b609">&#9670;&#160;</a></span>abort_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abort_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort the on-going write transfer. </p>
<p>It is safe to call <a class="el" href="classmbed_1_1_serial_base.html#a859436a72de08d7e4eb127e11ca4b609" title="Abort the on-going write transfer.">abort_write()</a> when there is no on-going transaction. </p>

</div>
</div>
<a id="a335c17fdb4ad3c94595b5cfe5496a7c7" name="a335c17fdb4ad3c94595b5cfe5496a7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335c17fdb4ad3c94595b5cfe5496a7c7">&#9670;&#160;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em> = <code>SERIAL_EVENT_RX_COMPLETE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>char_match</em> = <code>SERIAL_RESERVED_CHAR_MATCH</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin asynchronous reading using 8bit buffer. </p>
<p>The read operation ends with any of the enabled events and invokes registered callback function (which can be empty to not receive callback at all). Events that are not enabled by event argument are simply ignored. Operation has to be ended explicitly by calling <a class="el" href="classmbed_1_1_serial_base.html#a444087f07f1d2dac9f688e3891054893" title="Abort the on-going read transfer.">abort_read()</a> when no events are enabled. This function locks the deep sleep until any event has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer where received data will be stored </td></tr>
    <tr><td class="paramname">length</td><td>The buffer length in bytes </td></tr>
    <tr><td class="paramname">callback</td><td>The event callback function </td></tr>
    <tr><td class="paramname">event</td><td>The logical OR of RX events that should end operation </td></tr>
    <tr><td class="paramname">char_match</td><td>The matching character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if new transaction was started, -1 if transaction is already on-going </dd></dl>

</div>
</div>
<a id="a1ebd1e506e3a8abd2e193dbe159fa87f" name="a1ebd1e506e3a8abd2e193dbe159fa87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebd1e506e3a8abd2e193dbe159fa87f">&#9670;&#160;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em> = <code>SERIAL_EVENT_RX_COMPLETE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>char_match</em> = <code>SERIAL_RESERVED_CHAR_MATCH</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin asynchronous reading using 16bit buffer. </p>
<p>The read operation ends with any of the enabled events and invokes registered callback function (which can be empty to not receive callback at all). Events that are not enabled by event argument are simply ignored. Operation has to be ended explicitly by calling <a class="el" href="classmbed_1_1_serial_base.html#a444087f07f1d2dac9f688e3891054893" title="Abort the on-going read transfer.">abort_read()</a> when no events are enabled. This function locks the deep sleep until any event has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer where received data will be stored </td></tr>
    <tr><td class="paramname">length</td><td>The buffer length in bytes </td></tr>
    <tr><td class="paramname">callback</td><td>The event callback function </td></tr>
    <tr><td class="paramname">event</td><td>The logical OR of RX events that should end operation </td></tr>
    <tr><td class="paramname">char_match</td><td>The matching character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if new transaction was started, -1 if transaction is already on-going </dd></dl>

</div>
</div>
<a id="a444087f07f1d2dac9f688e3891054893" name="a444087f07f1d2dac9f688e3891054893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444087f07f1d2dac9f688e3891054893">&#9670;&#160;</a></span>abort_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abort_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort the on-going read transfer. </p>
<p>It is safe to call <a class="el" href="classmbed_1_1_serial_base.html#a444087f07f1d2dac9f688e3891054893" title="Abort the on-going read transfer.">abort_read()</a> when there is no on-going transaction. </p>

</div>
</div>
<a id="aac6c7090d9340149fb1979310baf9ef9" name="aac6c7090d9340149fb1979310baf9ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6c7090d9340149fb1979310baf9ef9">&#9670;&#160;</a></span>set_dma_usage_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int set_dma_usage_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal.html#ga9fb5be593465bb507b7bc23945ddf30c">DMAUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure DMA usage suggestion for non-blocking TX transfers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usage</td><td>The usage DMA hint for peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the usage was set, -1 if a transaction is on-going </dd></dl>

</div>
</div>
<a id="a8b50918e727c578a5df2e48c649433a2" name="a8b50918e727c578a5df2e48c649433a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b50918e727c578a5df2e48c649433a2">&#9670;&#160;</a></span>set_dma_usage_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int set_dma_usage_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal.html#ga9fb5be593465bb507b7bc23945ddf30c">DMAUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure DMA usage suggestion for non-blocking RX transfers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usage</td><td>The usage DMA hint for peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the usage was set, -1 if a transaction is on-going </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mbed</b></li><li class="navelem"><a class="el" href="classmbed_1_1_serial_base.html">SerialBase</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
