<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: EMACMemoryManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_e_m_a_c_memory_manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">EMACMemoryManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for EMACMemoryManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_e_m_a_c_memory_manager.png" usemap="#EMACMemoryManager_map" alt=""/>
  <map id="EMACMemoryManager_map" name="EMACMemoryManager_map">
<area href="class_net_stack_memory_manager.html" alt="NetStackMemoryManager" shape="rect" coords="0,0,168,24"/>
<area href="class_nanostack_memory_manager.html" alt="NanostackMemoryManager" shape="rect" coords="0,112,168,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa89815eef77cb4c080dc9d11c3914c49" id="r_aa89815eef77cb4c080dc9d11c3914c49"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#aa89815eef77cb4c080dc9d11c3914c49">Lifetime</a> { <a class="el" href="class_net_stack_memory_manager.html#aa89815eef77cb4c080dc9d11c3914c49af8b898e5cdc11227a665afec902f422a">POOL_ALLOCATED</a>
, <a class="el" href="class_net_stack_memory_manager.html#aa89815eef77cb4c080dc9d11c3914c49a5d71b484d345198c0e714ea1722f94b0">HEAP_ALLOCATED</a>
, <a class="el" href="class_net_stack_memory_manager.html#aa89815eef77cb4c080dc9d11c3914c49a8d6b5cada83510220f59e00ce86d4d92">CONSTANT</a>
, <a class="el" href="class_net_stack_memory_manager.html#aa89815eef77cb4c080dc9d11c3914c49a87129c163298099723f5eb9201684b70">VOLATILE</a>
 }</td></tr>
<tr class="separator:aa89815eef77cb4c080dc9d11c3914c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a594affb582c0d6353985659eade0ee6a" id="r_a594affb582c0d6353985659eade0ee6a"><td class="memItemLeft" align="right" valign="top">virtual net_stack_mem_buf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a594affb582c0d6353985659eade0ee6a">alloc_heap</a> (uint32_t size, uint32_t align)=0</td></tr>
<tr class="memdesc:a594affb582c0d6353985659eade0ee6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory buffer from the heap.  <br /></td></tr>
<tr class="separator:a594affb582c0d6353985659eade0ee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2985198195abc4b97e0fba1241855e87" id="r_a2985198195abc4b97e0fba1241855e87"><td class="memItemLeft" align="right" valign="top">virtual net_stack_mem_buf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a2985198195abc4b97e0fba1241855e87">alloc_pool</a> (uint32_t size, uint32_t align)=0</td></tr>
<tr class="memdesc:a2985198195abc4b97e0fba1241855e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory buffer chain from a pool.  <br /></td></tr>
<tr class="separator:a2985198195abc4b97e0fba1241855e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4aea6d09c85f539644cc745a5df7fe" id="r_a5a4aea6d09c85f539644cc745a5df7fe"><td class="memItemLeft" align="right" valign="top">net_stack_mem_buf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a5a4aea6d09c85f539644cc745a5df7fe">realloc_heap</a> (net_stack_mem_buf_t *orig_buf, uint32_t new_align, std::optional&lt; uint32_t &gt; new_len=std::nullopt, std::optional&lt; uint16_t &gt; new_header_skip_size=std::nullopt)</td></tr>
<tr class="memdesc:a5a4aea6d09c85f539644cc745a5df7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates a buffer or buffer chain as a contiguous (non-chained) heap buffer, freeing the original.  <br /></td></tr>
<tr class="separator:a5a4aea6d09c85f539644cc745a5df7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05add60c82a180db68e987eae04f0e9d" id="r_a05add60c82a180db68e987eae04f0e9d"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a05add60c82a180db68e987eae04f0e9d">get_pool_alloc_unit</a> (uint32_t align) const =0</td></tr>
<tr class="memdesc:a05add60c82a180db68e987eae04f0e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory buffer pool allocation unit.  <br /></td></tr>
<tr class="separator:a05add60c82a180db68e987eae04f0e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ac72c138c55a88860a7a74e827dca3" id="r_a45ac72c138c55a88860a7a74e827dca3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a45ac72c138c55a88860a7a74e827dca3">get_pool_size</a> ()</td></tr>
<tr class="memdesc:a45ac72c138c55a88860a7a74e827dca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory buffer pool size.  <br /></td></tr>
<tr class="separator:a45ac72c138c55a88860a7a74e827dca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fce7e0a07c3e4d5dff6d57de511f51d" id="r_a8fce7e0a07c3e4d5dff6d57de511f51d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a8fce7e0a07c3e4d5dff6d57de511f51d">free</a> (net_stack_mem_buf_t *buf)=0</td></tr>
<tr class="memdesc:a8fce7e0a07c3e4d5dff6d57de511f51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory buffer chain.  <br /></td></tr>
<tr class="separator:a8fce7e0a07c3e4d5dff6d57de511f51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1467962dd28f9891c245a6c52660f0" id="r_afc1467962dd28f9891c245a6c52660f0"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#afc1467962dd28f9891c245a6c52660f0">get_total_len</a> (const net_stack_mem_buf_t *buf) const =0</td></tr>
<tr class="memdesc:afc1467962dd28f9891c245a6c52660f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return total length of a memory buffer chain.  <br /></td></tr>
<tr class="separator:afc1467962dd28f9891c245a6c52660f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d43406cbf6dd7e3cc44bbf5464b480" id="r_a24d43406cbf6dd7e3cc44bbf5464b480"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a24d43406cbf6dd7e3cc44bbf5464b480">copy_to_buf</a> (net_stack_mem_buf_t *to_buf, const void *ptr, uint32_t len)</td></tr>
<tr class="memdesc:a24d43406cbf6dd7e3cc44bbf5464b480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from a raw buffer in memory to a memory buffer chain.  <br /></td></tr>
<tr class="separator:a24d43406cbf6dd7e3cc44bbf5464b480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c92a2583c617a77b07213c3dd8a9d2" id="r_a48c92a2583c617a77b07213c3dd8a9d2"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a48c92a2583c617a77b07213c3dd8a9d2">copy_from_buf</a> (void *ptr, uint32_t len, const net_stack_mem_buf_t *from_buf) const</td></tr>
<tr class="memdesc:a48c92a2583c617a77b07213c3dd8a9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from a memory buffer chain to a raw buffer in memory.  <br /></td></tr>
<tr class="separator:a48c92a2583c617a77b07213c3dd8a9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304679bfc9deeb21c6b3c036c0332138" id="r_a304679bfc9deeb21c6b3c036c0332138"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a304679bfc9deeb21c6b3c036c0332138">cat</a> (net_stack_mem_buf_t *to_buf, net_stack_mem_buf_t *cat_buf)=0</td></tr>
<tr class="memdesc:a304679bfc9deeb21c6b3c036c0332138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two memory buffer chains.  <br /></td></tr>
<tr class="separator:a304679bfc9deeb21c6b3c036c0332138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab408428bbda8bf9eb9f83abe9ce77ebd" id="r_ab408428bbda8bf9eb9f83abe9ce77ebd"><td class="memItemLeft" align="right" valign="top">virtual net_stack_mem_buf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#ab408428bbda8bf9eb9f83abe9ce77ebd">get_next</a> (const net_stack_mem_buf_t *buf) const =0</td></tr>
<tr class="memdesc:ab408428bbda8bf9eb9f83abe9ce77ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next buffer.  <br /></td></tr>
<tr class="separator:ab408428bbda8bf9eb9f83abe9ce77ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d2fa933a0b15a86613907dde97564d" id="r_ae8d2fa933a0b15a86613907dde97564d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#ae8d2fa933a0b15a86613907dde97564d">count_buffers</a> (const net_stack_mem_buf_t *buf)</td></tr>
<tr class="memdesc:ae8d2fa933a0b15a86613907dde97564d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of buffers in a buffer chain.  <br /></td></tr>
<tr class="separator:ae8d2fa933a0b15a86613907dde97564d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76415e26fb0db02bb2faf46f6f3ff024" id="r_a76415e26fb0db02bb2faf46f6f3ff024"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a76415e26fb0db02bb2faf46f6f3ff024">get_ptr</a> (const net_stack_mem_buf_t *buf) const =0</td></tr>
<tr class="memdesc:a76415e26fb0db02bb2faf46f6f3ff024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the payload of the buffer.  <br /></td></tr>
<tr class="separator:a76415e26fb0db02bb2faf46f6f3ff024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8661a315a5f1842ef7ecda9905bfb4f3" id="r_a8661a315a5f1842ef7ecda9905bfb4f3"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a8661a315a5f1842ef7ecda9905bfb4f3">get_len</a> (const net_stack_mem_buf_t *buf) const =0</td></tr>
<tr class="memdesc:a8661a315a5f1842ef7ecda9905bfb4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return payload size of this individual buffer (NOT including any chained buffers)  <br /></td></tr>
<tr class="separator:a8661a315a5f1842ef7ecda9905bfb4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9067726a9082ceb80bd469eb4ce6d91" id="r_af9067726a9082ceb80bd469eb4ce6d91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#af9067726a9082ceb80bd469eb4ce6d91">set_len</a> (net_stack_mem_buf_t *buf, uint32_t len)=0</td></tr>
<tr class="memdesc:af9067726a9082ceb80bd469eb4ce6d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the payload size of the buffer.  <br /></td></tr>
<tr class="separator:af9067726a9082ceb80bd469eb4ce6d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb27770836a2f75a24275799d286c7c" id="r_aaeb27770836a2f75a24275799d286c7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#aaeb27770836a2f75a24275799d286c7c">skip_header_space</a> (net_stack_mem_buf_t *buf, int32_t amount)=0</td></tr>
<tr class="memdesc:aaeb27770836a2f75a24275799d286c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips (or un-skips) header space from the buffer.  <br /></td></tr>
<tr class="separator:aaeb27770836a2f75a24275799d286c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bb5c373a8d857f706bdaaa08ef098d" id="r_ab3bb5c373a8d857f706bdaaa08ef098d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#ab3bb5c373a8d857f706bdaaa08ef098d">restore_header_space</a> (net_stack_mem_buf_t *buf, const int32_t amount)</td></tr>
<tr class="memdesc:ab3bb5c373a8d857f706bdaaa08ef098d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores previously skipped header space to the buffer.  <br /></td></tr>
<tr class="separator:ab3bb5c373a8d857f706bdaaa08ef098d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eef1a2b1003c7596d2bb47ac604098" id="r_a21eef1a2b1003c7596d2bb47ac604098"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#a21eef1a2b1003c7596d2bb47ac604098">get_header_skip_size</a> (net_stack_mem_buf_t *buf)=0</td></tr>
<tr class="memdesc:a21eef1a2b1003c7596d2bb47ac604098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of header bytes that are currently being skipped.  <br /></td></tr>
<tr class="separator:a21eef1a2b1003c7596d2bb47ac604098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e94f6f0c8d298a7bffa567ffe9dbf0" id="r_ab7e94f6f0c8d298a7bffa567ffe9dbf0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_stack_memory_manager.html#aa89815eef77cb4c080dc9d11c3914c49">Lifetime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#ab7e94f6f0c8d298a7bffa567ffe9dbf0">get_lifetime</a> (net_stack_mem_buf_t const *buf) const =0</td></tr>
<tr class="memdesc:ab7e94f6f0c8d298a7bffa567ffe9dbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lifetime of the buffer.  <br /></td></tr>
<tr class="separator:ab7e94f6f0c8d298a7bffa567ffe9dbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f976513299ea6bb3177e8c7f5fc00f" id="r_af0f976513299ea6bb3177e8c7f5fc00f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#af0f976513299ea6bb3177e8c7f5fc00f">set_on_pool_space_avail_cb</a> (<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void()&gt; cb)</td></tr>
<tr class="memdesc:af0f976513299ea6bb3177e8c7f5fc00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback which will be called when pool space becomes available.  <br /></td></tr>
<tr class="separator:af0f976513299ea6bb3177e8c7f5fc00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae5cf37b0df393dbcee1bee8661e283b9" id="r_ae5cf37b0df393dbcee1bee8661e283b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_stack_memory_manager.html#ae5cf37b0df393dbcee1bee8661e283b9">onPoolSpaceAvailCallback</a></td></tr>
<tr class="memdesc:ae5cf37b0df393dbcee1bee8661e283b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback which shall be called (if set) by the implementation after one or more buffer spaces become free in the pool.  <br /></td></tr>
<tr class="separator:ae5cf37b0df393dbcee1bee8661e283b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="_e_m_a_c_memory_manager_8h_source.html#l00045">45</a> of file <a class="el" href="_e_m_a_c_memory_manager_8h_source.html">EMACMemoryManager.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa89815eef77cb4c080dc9d11c3914c49" name="aa89815eef77cb4c080dc9d11c3914c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89815eef77cb4c080dc9d11c3914c49">&#9670;&#160;</a></span>Lifetime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="class_net_stack_memory_manager.html#aa89815eef77cb4c080dc9d11c3914c49">Lifetime</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa89815eef77cb4c080dc9d11c3914c49af8b898e5cdc11227a665afec902f422a" name="aa89815eef77cb4c080dc9d11c3914c49af8b898e5cdc11227a665afec902f422a"></a>POOL_ALLOCATED&#160;</td><td class="fielddoc"><p>Allocated from the memory manager's pool. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa89815eef77cb4c080dc9d11c3914c49a5d71b484d345198c0e714ea1722f94b0" name="aa89815eef77cb4c080dc9d11c3914c49a5d71b484d345198c0e714ea1722f94b0"></a>HEAP_ALLOCATED&#160;</td><td class="fielddoc"><p>Allocated from the memory manager's heap. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa89815eef77cb4c080dc9d11c3914c49a8d6b5cada83510220f59e00ce86d4d92" name="aa89815eef77cb4c080dc9d11c3914c49a8d6b5cada83510220f59e00ce86d4d92"></a>CONSTANT&#160;</td><td class="fielddoc"><p>Buffer points to constant data (e.g. in ROM) that will live forever. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa89815eef77cb4c080dc9d11c3914c49a87129c163298099723f5eb9201684b70" name="aa89815eef77cb4c080dc9d11c3914c49a87129c163298099723f5eb9201684b70"></a>VOLATILE&#160;</td><td class="fielddoc"><p>Buffer points to data from the application that will not live past the current network stack call. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_net_stack_memory_manager_8h_source.html#l00303">303</a> of file <a class="el" href="_net_stack_memory_manager_8h_source.html">NetStackMemoryManager.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a594affb582c0d6353985659eade0ee6a" name="a594affb582c0d6353985659eade0ee6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594affb582c0d6353985659eade0ee6a">&#9670;&#160;</a></span>alloc_heap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual net_stack_mem_buf_t * alloc_heap </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory buffer from the heap. </p>
<p>Memory buffer allocated from heap is always contiguous and can be arbitrary size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the memory to allocate in bytes </td></tr>
    <tr><td class="paramname">align</td><td>Memory alignment requirement in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated memory buffer, or NULL in case of error </dd></dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#a7dc0c0b73bcd00341d050f2f945b2a26">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="a2985198195abc4b97e0fba1241855e87" name="a2985198195abc4b97e0fba1241855e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2985198195abc4b97e0fba1241855e87">&#9670;&#160;</a></span>alloc_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual net_stack_mem_buf_t * alloc_pool </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory buffer chain from a pool. </p>
<p>Memory allocated from pool is contiguous if size is equal or less than (aligned) allocation unit, otherwise may be chained. Will typically come from fixed-size packet pool memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Total size of the memory to allocate in bytes </td></tr>
    <tr><td class="paramname">align</td><td>Memory alignment requirement for each buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated memory buffer chain, or NULL in case of error </dd></dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#ad04429d535b35528be2afa163e236e48">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="a5a4aea6d09c85f539644cc745a5df7fe" name="a5a4aea6d09c85f539644cc745a5df7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4aea6d09c85f539644cc745a5df7fe">&#9670;&#160;</a></span>realloc_heap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">net_stack_mem_buf_t * realloc_heap </td>
          <td>(</td>
          <td class="paramtype">net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>orig_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>new_align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>new_len</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint16_t &gt;&#160;</td>
          <td class="paramname"><em>new_header_skip_size</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocates a buffer or buffer chain as a contiguous (non-chained) heap buffer, freeing the original. </p>
<p>Only the visible data in the source buffer is copied, not any skipped headers. Data from chained buffers <em>will</em> be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_buf</td><td>Original buffer. Will be freed whether or not the new buffer is allocated. </td></tr>
    <tr><td class="paramname">new_align</td><td>Alignment to allocate the new buffer with </td></tr>
    <tr><td class="paramname">new_len</td><td>If set, this length will be used instead of the buffer's original length </td></tr>
    <tr><td class="paramname">new_header_skip_size</td><td>If set, this header skip size will be set on the new buffer. If unset, no header skip will be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new buffer, or nullptr if allocation failed. </dd></dl>

</div>
</div>
<a id="a05add60c82a180db68e987eae04f0e9d" name="a05add60c82a180db68e987eae04f0e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05add60c82a180db68e987eae04f0e9d">&#9670;&#160;</a></span>get_pool_alloc_unit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t get_pool_alloc_unit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>align</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get memory buffer pool allocation unit. </p>
<p>Returns the maximum size of contiguous memory that can be allocated from a pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td>Memory alignment requirement in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contiguous memory size </dd></dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#a0c66a43bdcb55fbc096f4e41349f7ca1">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="a45ac72c138c55a88860a7a74e827dca3" name="a45ac72c138c55a88860a7a74e827dca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ac72c138c55a88860a7a74e827dca3">&#9670;&#160;</a></span>get_pool_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_pool_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get memory buffer pool size. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of pool buffers that can be allocated at any one time </dd></dl>

<p class="definition">Definition at line <a class="el" href="_net_stack_memory_manager_8h_source.html#l00123">123</a> of file <a class="el" href="_net_stack_memory_manager_8h_source.html">NetStackMemoryManager.h</a>.</p>

</div>
</div>
<a id="a8fce7e0a07c3e4d5dff6d57de511f51d" name="a8fce7e0a07c3e4d5dff6d57de511f51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fce7e0a07c3e4d5dff6d57de511f51d">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void free </td>
          <td>(</td>
          <td class="paramtype">net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free memory buffer chain. </p>
<p>Frees all buffers from the chained list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Memory buffer chain to be freed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#a517550bbddd2e0d281f4930914516839">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="afc1467962dd28f9891c245a6c52660f0" name="afc1467962dd28f9891c245a6c52660f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1467962dd28f9891c245a6c52660f0">&#9670;&#160;</a></span>get_total_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t get_total_len </td>
          <td>(</td>
          <td class="paramtype">const net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return total length of a memory buffer chain. </p>
<p>Returns a total length of this buffer and any following buffers in the chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Memory buffer chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total length in bytes </dd></dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#acc2a1156f2d67bcc685aef34da91ac5c">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="a24d43406cbf6dd7e3cc44bbf5464b480" name="a24d43406cbf6dd7e3cc44bbf5464b480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d43406cbf6dd7e3cc44bbf5464b480">&#9670;&#160;</a></span>copy_to_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void copy_to_buf </td>
          <td>(</td>
          <td class="paramtype">net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>to_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from a raw buffer in memory to a memory buffer chain. </p>
<p>Copies data to a buffer chain. Copy operation does not adjust the lengths of the copied-to memory buffer chain, so chain total length must match the copied length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_buf</td><td>Memory buffer chain to copy to </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to data </td></tr>
    <tr><td class="paramname">len</td><td>Data length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48c92a2583c617a77b07213c3dd8a9d2" name="a48c92a2583c617a77b07213c3dd8a9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c92a2583c617a77b07213c3dd8a9d2">&#9670;&#160;</a></span>copy_from_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t copy_from_buf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>from_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from a memory buffer chain to a raw buffer in memory. </p>
<p>Header skip bytes are processed, so the copy will begin AFTER the header bytes of <code>from_buf</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Data length </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to data </td></tr>
    <tr><td class="paramname">from_buf</td><td>Memory buffer chain to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the data that was copied </dd></dl>

</div>
</div>
<a id="a304679bfc9deeb21c6b3c036c0332138" name="a304679bfc9deeb21c6b3c036c0332138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304679bfc9deeb21c6b3c036c0332138">&#9670;&#160;</a></span>cat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cat </td>
          <td>(</td>
          <td class="paramtype">net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>to_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>cat_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate two memory buffer chains. </p>
<p>Concatenates buffer chain to end of the other buffer chain. Concatenated-to buffer total length is adjusted accordingly. cat_buf must point to the start of a the chain. After concatenation to_buf's chain now owns those buffers, and they will be freed when the to_buf chain is freed.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is forbidden for <code>cat_buf</code> to have skipped header bytes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_buf</td><td>Memory buffer chain to concatenate to </td></tr>
    <tr><td class="paramname">cat_buf</td><td>Memory buffer chain to concatenate </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#adef1a6e4e8a3151cc4b4be527b8d1e95">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="ab408428bbda8bf9eb9f83abe9ce77ebd" name="ab408428bbda8bf9eb9f83abe9ce77ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab408428bbda8bf9eb9f83abe9ce77ebd">&#9670;&#160;</a></span>get_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual net_stack_mem_buf_t * get_next </td>
          <td>(</td>
          <td class="paramtype">const net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next buffer. </p>
<p>Returns the next buffer from the memory buffer chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Memory buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next memory buffer, or NULL if last </dd></dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#a1db4ee9e072b3fac2fcb8abe17309d27">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="ae8d2fa933a0b15a86613907dde97564d" name="ae8d2fa933a0b15a86613907dde97564d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d2fa933a0b15a86613907dde97564d">&#9670;&#160;</a></span>count_buffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t count_buffers </td>
          <td>(</td>
          <td class="paramtype">const net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of buffers in a buffer chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Memory buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of buffers in the chain </dd></dl>

<p class="definition">Definition at line <a class="el" href="_net_stack_memory_manager_8h_source.html#l00207">207</a> of file <a class="el" href="_net_stack_memory_manager_8h_source.html">NetStackMemoryManager.h</a>.</p>

</div>
</div>
<a id="a76415e26fb0db02bb2faf46f6f3ff024" name="a76415e26fb0db02bb2faf46f6f3ff024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76415e26fb0db02bb2faf46f6f3ff024">&#9670;&#160;</a></span>get_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void * get_ptr </td>
          <td>(</td>
          <td class="paramtype">const net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to the payload of the buffer. </p>
<p>Note that this is affected by the current header skip size (see below)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Memory buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the payload </dd></dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#a4d3d811b7bca7f8577206d4a4b3d2755">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="a8661a315a5f1842ef7ecda9905bfb4f3" name="a8661a315a5f1842ef7ecda9905bfb4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8661a315a5f1842ef7ecda9905bfb4f3">&#9670;&#160;</a></span>get_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t get_len </td>
          <td>(</td>
          <td class="paramtype">const net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return payload size of this individual buffer (NOT including any chained buffers) </p>
<p>Note that this is affected by the current header skip size (see below)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Memory buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes </dd></dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#accfc00a7916fda67471502efe3f5c205">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="af9067726a9082ceb80bd469eb4ce6d91" name="af9067726a9082ceb80bd469eb4ce6d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9067726a9082ceb80bd469eb4ce6d91">&#9670;&#160;</a></span>set_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_len </td>
          <td>(</td>
          <td class="paramtype">net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the payload size of the buffer. </p>
<p>The allocated payload size will not change. It is not permitted to change the length of a buffer that is not the first (or only) in a chain.</p>
<p>Note that this is affected by the current header skip size (see below)</p>
<p>*Note as of Dec 2024: Different implementations (<a class="el" href="class_nanostack.html">Nanostack</a> vs LwIP) disagree about how to implement this operation. Specifically, if called on the head of a buffer chain, the LwIP implementation allows changing the length of the chain as a whole. However, the <a class="el" href="class_nanostack.html">Nanostack</a> implementation does not and only can change the length of the head buffer. For fear of breaking existing code, I do not want to change this behavior. So, if constructing a buffer chain, it is safest to set the buffer lengths first before building the chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Memory buffer </td></tr>
    <tr><td class="paramname">len</td><td>Payload size, must be less or equal to the allocated size </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#a0c5cab5ee63a6549f45ffa5e15f370ef">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="aaeb27770836a2f75a24275799d286c7c" name="aaeb27770836a2f75a24275799d286c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb27770836a2f75a24275799d286c7c">&#9670;&#160;</a></span>skip_header_space()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void skip_header_space </td>
          <td>(</td>
          <td class="paramtype">net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips (or un-skips) header space from the buffer. </p>
<p>Skipping n bytes of header space causes the buffer's payload pointer to refer to a location n bytes after the base address of the packet buffer, and the length of the buffer to be decreased by n.</p>
<p>This is commonly used to skip protocol headers in network packets. For example, if you have an Ethernet frame, skipping 14 bytes of header space will cause the "start" of the packet buffer to point to the IP header instead.</p>
<p>Multiple calls to this function add together, so for example if you first skip 14 bytes, then -4, then 10, the result will be 20 total bytes of skipped header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to operate on. </td></tr>
    <tr><td class="paramname">amount</td><td>Amount of header space to skip. Negative values are allowed and cause previously skipped header space to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Skipping a larger total header space than the size of the first buffer in the chain, or skipping a negative total header space, results in undefined behavior. </dd></dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#aa49d1bfba902dc20673dad2e89180c43">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="ab3bb5c373a8d857f706bdaaa08ef098d" name="ab3bb5c373a8d857f706bdaaa08ef098d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bb5c373a8d857f706bdaaa08ef098d">&#9670;&#160;</a></span>restore_header_space()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void restore_header_space </td>
          <td>(</td>
          <td class="paramtype">net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores previously skipped header space to the buffer. </p>
<p>This function is the inverse of <code><a class="el" href="class_net_stack_memory_manager.html#aaeb27770836a2f75a24275799d286c7c" title="Skips (or un-skips) header space from the buffer.">skip_header_space()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to operate on. </td></tr>
    <tr><td class="paramname">amount</td><td>Amount of header space to skip. Negative values are allowed and cause previously skipped header space to be removed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_net_stack_memory_manager_8h_source.html#l00289">289</a> of file <a class="el" href="_net_stack_memory_manager_8h_source.html">NetStackMemoryManager.h</a>.</p>

</div>
</div>
<a id="a21eef1a2b1003c7596d2bb47ac604098" name="a21eef1a2b1003c7596d2bb47ac604098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21eef1a2b1003c7596d2bb47ac604098">&#9670;&#160;</a></span>get_header_skip_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t get_header_skip_size </td>
          <td>(</td>
          <td class="paramtype">net_stack_mem_buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of header bytes that are currently being skipped. </p>
<p>This is the aggregate result of all <code><a class="el" href="class_net_stack_memory_manager.html#aaeb27770836a2f75a24275799d286c7c" title="Skips (or un-skips) header space from the buffer.">skip_header_space()</a></code> / <code><a class="el" href="class_net_stack_memory_manager.html#ab3bb5c373a8d857f706bdaaa08ef098d" title="Restores previously skipped header space to the buffer.">restore_header_space()</a></code> calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to operate on. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#a200221715d014577a5afc47b30f21214">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="ab7e94f6f0c8d298a7bffa567ffe9dbf0" name="ab7e94f6f0c8d298a7bffa567ffe9dbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e94f6f0c8d298a7bffa567ffe9dbf0">&#9670;&#160;</a></span>get_lifetime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_net_stack_memory_manager.html#aa89815eef77cb4c080dc9d11c3914c49">Lifetime</a> get_lifetime </td>
          <td>(</td>
          <td class="paramtype">net_stack_mem_buf_t const *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the lifetime of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Memory buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_nanostack_memory_manager.html#aca3bbe4a60b343f8b9094106377f2b96">NanostackMemoryManager</a>.</p>

</div>
</div>
<a id="af0f976513299ea6bb3177e8c7f5fc00f" name="af0f976513299ea6bb3177e8c7f5fc00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f976513299ea6bb3177e8c7f5fc00f">&#9670;&#160;</a></span>set_on_pool_space_avail_cb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_on_pool_space_avail_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set callback which will be called when pool space becomes available. </p>
<dl class="section warning"><dt>Warning</dt><dd>The callback could be called from any thread, and should make no assumptions about being in the same thread as anything else.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback to call </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_net_stack_memory_manager_8h_source.html#l00325">325</a> of file <a class="el" href="_net_stack_memory_manager_8h_source.html">NetStackMemoryManager.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="ae5cf37b0df393dbcee1bee8661e283b9" name="ae5cf37b0df393dbcee1bee8661e283b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cf37b0df393dbcee1bee8661e283b9">&#9670;&#160;</a></span>onPoolSpaceAvailCallback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;void()&gt; onPoolSpaceAvailCallback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback which shall be called (if set) by the implementation after one or more buffer spaces become free in the pool. </p>
<p>This is used by zero-copy Ethernet MACs as a hint that now is a good time to allocate fresh buffers off the pool into Ethernet descriptors. It <em>is</em> legal to call this function if you aren't totally sure new memory is available &ndash; the mac will try to allocate more buffers, and if it can't, oh well. However, it is not legal for memory to become available without a call to this function. Such a situation might lead to a lockup of the MAC due to not having memory allocated for Rx. </p>

<p class="definition">Definition at line <a class="el" href="_net_stack_memory_manager_8h_source.html#l00065">65</a> of file <a class="el" href="_net_stack_memory_manager_8h_source.html">NetStackMemoryManager.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_e_m_a_c_memory_manager.html">EMACMemoryManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
