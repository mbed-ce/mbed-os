<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: SPI Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmbed_1_1_s_p_i.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">SPI Class Reference<div class="ingroups"><a class="el" href="group__mbed-os-public.html">Public API</a> &raquo; <a class="el" href="group__drivers-public-api.html">Drivers</a> &raquo; <a class="el" href="group__drivers-public-api-spi.html">SPI</a> &raquo; <a class="el" href="group__drivers___s_p_i.html">SPI class</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>An SPI Master, used for communicating with SPI slave devices.  
 <a href="classmbed_1_1_s_p_i.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_p_i_8h_source.html">SPI.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SPI:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmbed_1_1_s_p_i.png" usemap="#SPI_map" alt=""/>
  <map id="SPI_map" name="SPI_map">
<area href="classmbed_1_1_non_copyable.html" alt="NonCopyable&lt; SPI &gt;" shape="rect" coords="0,0,132,24"/>
<area href="class_e_m_w3080_b___s_p_i.html" alt="EMW3080B_SPI" shape="rect" coords="0,112,132,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21d684ae9ab826c863c3d198fb761bad" id="r_a21d684ae9ab826c863c3d198fb761bad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a21d684ae9ab826c863c3d198fb761bad">SPI</a> (PinName mosi, PinName miso, PinName sclk, PinName ssel=NC)</td></tr>
<tr class="memdesc:a21d684ae9ab826c863c3d198fb761bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> master connected to the specified pins.  <br /></td></tr>
<tr class="separator:a21d684ae9ab826c863c3d198fb761bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0616bc0845ecebb978b0913bbe118262" id="r_a0616bc0845ecebb978b0913bbe118262"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a0616bc0845ecebb978b0913bbe118262">SPI</a> (PinName mosi, PinName miso, PinName sclk, PinName ssel, <a class="el" href="structmbed_1_1use__gpio__ssel__t.html">use_gpio_ssel_t</a>)</td></tr>
<tr class="memdesc:a0616bc0845ecebb978b0913bbe118262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> master connected to the specified pins.  <br /></td></tr>
<tr class="separator:a0616bc0845ecebb978b0913bbe118262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab110082bbac4fc7d1a5ceb6942f4b5c0" id="r_ab110082bbac4fc7d1a5ceb6942f4b5c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#ab110082bbac4fc7d1a5ceb6942f4b5c0">SPI</a> (const <a class="el" href="structspi__pinmap__t.html">spi_pinmap_t</a> &amp;static_pinmap)</td></tr>
<tr class="memdesc:ab110082bbac4fc7d1a5ceb6942f4b5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> master connected to the specified pins.  <br /></td></tr>
<tr class="separator:ab110082bbac4fc7d1a5ceb6942f4b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b90429f64efdd3708234ddcc051a7c7" id="r_a3b90429f64efdd3708234ddcc051a7c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a3b90429f64efdd3708234ddcc051a7c7">SPI</a> (const <a class="el" href="structspi__pinmap__t.html">spi_pinmap_t</a> &amp;static_pinmap, PinName ssel)</td></tr>
<tr class="memdesc:a3b90429f64efdd3708234ddcc051a7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> master connected to the specified pins.  <br /></td></tr>
<tr class="separator:a3b90429f64efdd3708234ddcc051a7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7627faa611c3645626b6b627755fcae7" id="r_a7627faa611c3645626b6b627755fcae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a7627faa611c3645626b6b627755fcae7">format</a> (int bits, int mode=0)</td></tr>
<tr class="memdesc:a7627faa611c3645626b6b627755fcae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the data transmission format.  <br /></td></tr>
<tr class="separator:a7627faa611c3645626b6b627755fcae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4426901f2bcededa2ae9c5e6547b9a2a" id="r_a4426901f2bcededa2ae9c5e6547b9a2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a4426901f2bcededa2ae9c5e6547b9a2a">frequency</a> (int hz=1000000)</td></tr>
<tr class="memdesc:a4426901f2bcededa2ae9c5e6547b9a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the SPI bus clock frequency.  <br /></td></tr>
<tr class="separator:a4426901f2bcededa2ae9c5e6547b9a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594e0eb0068da0fdc3d57e2d018c1994" id="r_a594e0eb0068da0fdc3d57e2d018c1994"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a594e0eb0068da0fdc3d57e2d018c1994">write</a> (int value)</td></tr>
<tr class="memdesc:a594e0eb0068da0fdc3d57e2d018c1994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the SPI Slave and return the response.  <br /></td></tr>
<tr class="separator:a594e0eb0068da0fdc3d57e2d018c1994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f3e630e7940255c89f170afd657c7e" id="r_a18f3e630e7940255c89f170afd657c7e"><td class="memTemplParams" colspan="2">template&lt;typename WordT &gt; </td></tr>
<tr class="memitem:a18f3e630e7940255c89f170afd657c7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; WordT &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a18f3e630e7940255c89f170afd657c7e">write</a> (const WordT *tx_buffer, int tx_length, WordT *rx_buffer, int rx_length)</td></tr>
<tr class="memdesc:a18f3e630e7940255c89f170afd657c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Slave and obtain the response.  <br /></td></tr>
<tr class="separator:a18f3e630e7940255c89f170afd657c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67df83ace240f53c1276e24a37ff84c" id="r_ad67df83ace240f53c1276e24a37ff84c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#ad67df83ace240f53c1276e24a37ff84c">lock</a> (void)</td></tr>
<tr class="memdesc:ad67df83ace240f53c1276e24a37ff84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire exclusive access to this <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus.  <br /></td></tr>
<tr class="separator:ad67df83ace240f53c1276e24a37ff84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d882b4e464e4f4bd59eab6c75297bda" id="r_a5d882b4e464e4f4bd59eab6c75297bda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a5d882b4e464e4f4bd59eab6c75297bda">unlock</a> (void)</td></tr>
<tr class="memdesc:a5d882b4e464e4f4bd59eab6c75297bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release exclusive access to this <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus.  <br /></td></tr>
<tr class="separator:a5d882b4e464e4f4bd59eab6c75297bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9e3e51760dbdc066b1d082e496719e" id="r_abc9e3e51760dbdc066b1d082e496719e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#abc9e3e51760dbdc066b1d082e496719e">select</a> (void)</td></tr>
<tr class="memdesc:abc9e3e51760dbdc066b1d082e496719e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert the Slave Select line and acquire exclusive access to this <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus.  <br /></td></tr>
<tr class="separator:abc9e3e51760dbdc066b1d082e496719e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae77235b32f5522d5d881baf2c52210" id="r_a0ae77235b32f5522d5d881baf2c52210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a0ae77235b32f5522d5d881baf2c52210">deselect</a> (void)</td></tr>
<tr class="memdesc:a0ae77235b32f5522d5d881baf2c52210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deassert the Slave Select line, releasing exclusive access to this <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus.  <br /></td></tr>
<tr class="separator:a0ae77235b32f5522d5d881baf2c52210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162d7008eb2691cb49f9f82796a63536" id="r_a162d7008eb2691cb49f9f82796a63536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a162d7008eb2691cb49f9f82796a63536">set_default_write_value</a> (char data)</td></tr>
<tr class="memdesc:a162d7008eb2691cb49f9f82796a63536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default write data.  <br /></td></tr>
<tr class="separator:a162d7008eb2691cb49f9f82796a63536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04175d1089a2e1ff86ca2f03f133864a" id="r_a04175d1089a2e1ff86ca2f03f133864a"><td class="memTemplParams" colspan="2">template&lt;typename WordT &gt; </td></tr>
<tr class="memitem:a04175d1089a2e1ff86ca2f03f133864a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; WordT &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a04175d1089a2e1ff86ca2f03f133864a">transfer</a> (const WordT *tx_buffer, int tx_length, <a class="el" href="classmbed_1_1_cache_aligned_buffer.html">CacheAlignedBuffer</a>&lt; WordT &gt; &amp;rx_buffer, int rx_length, const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;<a class="el" href="group__platform___callback.html#ga90e30db9c535d448cd949f7f55bb8f31">callback</a>, int event=<a class="el" href="group__hal___s_p_i_events.html#ga84a652fdfd9732b4d6348443374603e4">SPI_EVENT_COMPLETE</a>)</td></tr>
<tr class="memdesc:a04175d1089a2e1ff86ca2f03f133864a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start non-blocking SPI transfer.  <br /></td></tr>
<tr class="separator:a04175d1089a2e1ff86ca2f03f133864a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aacbea21313b9ffc90cf79fcb2a91f9" id="r_a2aacbea21313b9ffc90cf79fcb2a91f9"><td class="memTemplParams" colspan="2">template&lt;typename WordT &gt; </td></tr>
<tr class="memitem:a2aacbea21313b9ffc90cf79fcb2a91f9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; WordT &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a2aacbea21313b9ffc90cf79fcb2a91f9">transfer_and_wait</a> (const WordT *tx_buffer, int tx_length, <a class="el" href="classmbed_1_1_cache_aligned_buffer.html">CacheAlignedBuffer</a>&lt; WordT &gt; &amp;rx_buffer, int rx_length, rtos::Kernel::Clock::duration_u32 timeout=<a class="el" href="namespacertos_1_1_kernel.html#a29baed0762de3912b6b7592150a9498e">rtos::Kernel::wait_for_u32_forever</a>)</td></tr>
<tr class="memdesc:a2aacbea21313b9ffc90cf79fcb2a91f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start SPI transfer and wait until it is complete.  <br /></td></tr>
<tr class="separator:a2aacbea21313b9ffc90cf79fcb2a91f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90253410d768f60403698f5f383d1931" id="r_a90253410d768f60403698f5f383d1931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a90253410d768f60403698f5f383d1931">abort_transfer</a> ()</td></tr>
<tr class="memdesc:a90253410d768f60403698f5f383d1931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the on-going <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> transfer, if any, and continue with transfers in the queue, if any.  <br /></td></tr>
<tr class="separator:a90253410d768f60403698f5f383d1931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7b4dd10bf4f4bb5eab6bdd11cebd44" id="r_aad7b4dd10bf4f4bb5eab6bdd11cebd44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#aad7b4dd10bf4f4bb5eab6bdd11cebd44">clear_transfer_buffer</a> ()</td></tr>
<tr class="memdesc:aad7b4dd10bf4f4bb5eab6bdd11cebd44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue of transfers.  <br /></td></tr>
<tr class="separator:aad7b4dd10bf4f4bb5eab6bdd11cebd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7787a47c785a57ddd0307add8be643e1" id="r_a7787a47c785a57ddd0307add8be643e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a7787a47c785a57ddd0307add8be643e1">abort_all_transfers</a> ()</td></tr>
<tr class="memdesc:a7787a47c785a57ddd0307add8be643e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue of transfers and abort any on-going transfer.  <br /></td></tr>
<tr class="separator:a7787a47c785a57ddd0307add8be643e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4885d525858929a6654d0da30dd77955" id="r_a4885d525858929a6654d0da30dd77955"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_s_p_i.html#a4885d525858929a6654d0da30dd77955">set_dma_usage</a> (<a class="el" href="group__hal.html#ga9fb5be593465bb507b7bc23945ddf30c">DMAUsage</a> usage)</td></tr>
<tr class="memdesc:a4885d525858929a6654d0da30dd77955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DMA usage suggestion for non-blocking transfers.  <br /></td></tr>
<tr class="separator:a4885d525858929a6654d0da30dd77955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An SPI Master, used for communicating with SPI slave devices. </p>
<p>The default format is set to 8-bits, mode 0, and a clock frequency of 1MHz.</p>
<dl class="section note"><dt>Note</dt><dd>Synchronization level: Thread safe</dd></dl>
<p>SPI allows you to transfer data to and from peripheral devices using single-word transfers, transactions, or an asynchronous API.</p>
<p>Here's how to talk to a chip using the single-word API: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classmbed_1_1_s_p_i.html">SPI</a> device(SPI_MOSI, SPI_MISO, SPI_SCLK, SPI_CS, use_gpio_ssel)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    device.<a class="code hl_function" href="classmbed_1_1_s_p_i.html#a7627faa611c3645626b6b627755fcae7">format</a>(8, 0);</div>
<div class="line"> </div>
<div class="line">    device.lock();</div>
<div class="line">    device.select();</div>
<div class="line">    <span class="keywordtype">int</span> response = device.write(0x0A);</div>
<div class="line">    <span class="keywordtype">int</span> response2 = device.write(0x0B);</div>
<div class="line">    device.deselect();</div>
<div class="line">    device.unlock();</div>
<div class="line">}</div>
<div class="ttc" id="aclassmbed_1_1_s_p_i_html"><div class="ttname"><a href="classmbed_1_1_s_p_i.html">mbed::SPI</a></div><div class="ttdoc">An SPI Master, used for communicating with SPI slave devices.</div><div class="ttdef"><b>Definition</b> <a href="_s_p_i_8h_source.html#l00266">SPI.h:266</a></div></div>
<div class="ttc" id="aclassmbed_1_1_s_p_i_html_a7627faa611c3645626b6b627755fcae7"><div class="ttname"><a href="classmbed_1_1_s_p_i.html#a7627faa611c3645626b6b627755fcae7">mbed::SPI::format</a></div><div class="ttdeci">void format(int bits, int mode=0)</div><div class="ttdoc">Configure the data transmission format.</div></div>
</div><!-- fragment --><p>And here's how to do the same thing using a transaction: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classmbed_1_1_s_p_i.html">SPI</a> device(SPI_MOSI, SPI_MISO, SPI_SCLK, SPI_CS, use_gpio_ssel)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    device.<a class="code hl_function" href="classmbed_1_1_s_p_i.html#a7627faa611c3645626b6b627755fcae7">format</a>(8, 0);</div>
<div class="line"> </div>
<div class="line">    uint8_t command[2] = {0x0A, 0x0B};</div>
<div class="line">    uint8_t response[2];</div>
<div class="line">    <span class="keywordtype">int</span> result = device.write(command, <span class="keyword">sizeof</span>(command), response, <span class="keyword">sizeof</span>(response));</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Hardware vs Software Chip Selects</h1>
<p>Most ARM chips have specific pins marked as "hardware chip selects". This means that they are connected to the SPI peripheral and are automatically brought low by hardware when data is sent. However, chips often only have only one pin for each <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus that can be used as a hardware chip select. If you wish to use multiple peripheral devices with one <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus, or just don't have access to the HW CS pin, you must use the SPI object in "GPIO chip select" mode.</p>
<p>To use GPIO CS mode, simply pass the CS pin as the 4th constructor parameter, then pass the special constant <code>use_gpio_ssel</code> as the 5th parameter. This puts the object in GPIO mode, where it will operate the CS line as a regular GPIO pin before and after doing an <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> transfer. This mode is marginally slower than HW CS mode, but otherwise should offer the same functionality. In fact, since the pin mapping is more flexible, it may be advisable to use GPIO CS mode by default.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is not recommended to control the CS line using a separate <a class="el" href="classmbed_1_1_digital_out.html" title="A digital output, used for setting the state of a pin.">DigitalOut</a> instance! This was needed in very old Mbed versions but should now be considered a legacy practice. Not only does it make it difficult to use the asynchronous API, but it can also lead to corner cases which corrupt data. The CS line, whether done through GPIO or HW, should always be managed through the <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> class.</dd></dl>
<h1>Sharing a Bus</h1>
<p>Multiple SPI devices may share the same physical bus, so long as each has its own dedicated chip select (CS) pin. To implement this sharing, each chip's driver should create its own instance of the <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> class, passing the same MOSI, MISO, and SCLK pins but a different CS pin. Mbed OS will internally share the SPI hardware between these objects. Note that this is <em>completely different</em> from how the <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> class handles sharing.</p>
<h1>Frame/Word Size</h1>
<p>Mbed OS supports configuration of the SPI frame size, also known as the word size, which controls how many bits are sent in one transfer operation (one call to <a class="el" href="classmbed_1_1_s_p_i.html#a594e0eb0068da0fdc3d57e2d018c1994" title="Write to the SPI Slave and return the response.">SPI::write()</a>). This parameter should match the "register size" of the SPI peripheral that you are talking to. For example, if you're working with a chip which uses 16-bit registers, you should set the frame size to 16 using <a class="el" href="classmbed_1_1_s_p_i.html#a7627faa611c3645626b6b627755fcae7" title="Configure the data transmission format.">SPI::format()</a>. Some Mbed devices also support 32-bit frames &ndash; use the <code>DEVICE_SPI_32BIT_WORDS</code> feature macro to test if yours does.</p>
<p>The frame size controls the effective width of data written and read from the chip. For example, if you set frame size to 8, <a class="el" href="classmbed_1_1_s_p_i.html#a594e0eb0068da0fdc3d57e2d018c1994" title="Write to the SPI Slave and return the response.">SPI::write(int)</a> will take one byte and return one byte, but if you set it to 16, <a class="el" href="classmbed_1_1_s_p_i.html#a594e0eb0068da0fdc3d57e2d018c1994" title="Write to the SPI Slave and return the response.">SPI::write(int)</a> will take a 16 bit value and return a 16 bit value. You can also do transactions with frame sizes other than 8. Just be sure to pass the length in bytes, not words!</p>
<p>It should be noted that changing the frame size can perform an apparent "endian swap" on data being transmitted. For example, suppose you have the 32-bit integer 0x01020408. On a little-endian processor, this will be encoded with the LSByte <em>first</em> in memory: <code>08 04 02 01</code>. If you send that integer using one-byte word size, it will appear as such. Consider the following example:</p>
<div class="fragment"><div class="line">spi.format(8, 0);</div>
<div class="line">uint32_t myInteger = 0x01020408;</div>
<div class="line">spi.write(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(&amp;myInteger), <span class="keyword">sizeof</span>(myInteger), <span class="keyword">nullptr</span>, 0);</div>
</div><!-- fragment --><p>If you ran this code, then used a logic analyzer to view the bytes on the MOSI line, it would show bytes matching the layout of the integer in memory:</p>
<pre>
MOSI -&gt; 08 04 02 01
</pre><p>But what about if you used a 32-bit frame size?</p>
<div class="fragment"><div class="line">spi.format(32, 0);</div>
<div class="line">uint32_t myInteger = 0x01020408;</div>
<div class="line">spi.write&lt;uint32_t&gt;(&amp;myInteger, <span class="keyword">sizeof</span>(myInteger), <span class="keyword">nullptr</span>, 0);</div>
</div><!-- fragment --><p>In this case, the complete 32-bit integer is sent as a single unit, from its MSBit to its LSBit, without breaking it into bytes. This will send the data in an order different from the order in memory. Viewed as bytes, it would look like:</p>
<pre>
MOSI -&gt; 01 02 04 08
</pre><p>But viewed by a peripheral chip which uses 32-bit <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> words, it would look like:</p>
<pre>
MOSI -&gt; 0x01020408
</pre><p>When viewed as bytes, it's almost as if you did an endian swap on the data before sending it, but in fact it's standard SPI behavior when using frame sizes greater than one byte. This same rule applies to receiving data, so be sure to check examples in the datasheet to determine what frame size to use and whether byte swapping is needed when working with an external chip.</p>
<dl class="section note"><dt>Note</dt><dd>Some Mbed targets support frame sizes that are not standard integer sizes, e.g. 4 bits, 7 bits, or 24 bits. However, the behavior of these frame sizes is currently not tested, and you may need to test what works or inspect your target's <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> driver code. More work is needed to make these consistent. When available, using these frame sizes requires writing each word to be transmitted into the next-largest C integer type. For example, to send 24-bit frames, you would create an array of uint32_ts and write each 24-bit integer into its own uint32_t. Then you would pass in the byte length of the array (number of frames * 4, NOT number of frames * 3) to the <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> driver.</dd></dl>
<h1>Asynchronous API</h1>
<p>On many processors, Mbed OS also supports asynchronous SPI. This feature allows you to run SPI transfers completely in the background, while other threads execute in the foreground. This can be extremely useful if you need to send large amounts of data over the SPI bus but don't want to block your main thread for ages. To see if your processor supports async SPI, look for the DEVICE_SPI_ASYNCH macro.</p>
<p>The asynchronous API has two different modes: nonblocking (where your thread can keep running, and the transfer calls a callback when finished) and blocking (where your thread blocks for the duration of the transfer but others can execute). Here's a sample of how to send the same data as above using the blocking async API:</p>
<p>Note that when using the asynchronous API, you must use the <a class="el" href="classmbed_1_1_cache_aligned_buffer.html" title="CacheAlignedBuffer is used by Mbed in locations where we need a cache-aligned buffer.">CacheAlignedBuffer</a> class when declaring the receive buffer. This is because some processors' async <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> implementations require the received buffer to be at an address which is aligned to the processor cache line size. <a class="el" href="classmbed_1_1_cache_aligned_buffer.html" title="CacheAlignedBuffer is used by Mbed in locations where we need a cache-aligned buffer.">CacheAlignedBuffer</a> takes care of this for you and provides functions (data(), begin(), end()) to access the underlying data in the buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classmbed_1_1_s_p_i.html">SPI</a> device(SPI_MOSI, SPI_MISO, SPI_SCLK, SPI_CS, use_gpio_ssel)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    device.<a class="code hl_function" href="classmbed_1_1_s_p_i.html#a7627faa611c3645626b6b627755fcae7">format</a>(8, 0);</div>
<div class="line"> </div>
<div class="line">    uint8_t command[2] = {0x0A, 0x0B};</div>
<div class="line">    <a class="code hl_class" href="classmbed_1_1_cache_aligned_buffer.html">CacheAlignedBuffer&lt;uint8_t, 2&gt;</a> response;</div>
<div class="line">    <span class="keywordtype">int</span> result = device.transfer_and_wait(command, <span class="keyword">sizeof</span>(command), response, <span class="keyword">sizeof</span>(command));</div>
<div class="line">}</div>
<div class="ttc" id="aclassmbed_1_1_cache_aligned_buffer_html"><div class="ttname"><a href="classmbed_1_1_cache_aligned_buffer.html">mbed::CacheAlignedBuffer</a></div><div class="ttdoc">CacheAlignedBuffer is used by Mbed in locations where we need a cache-aligned buffer.</div><div class="ttdef"><b>Definition</b> <a href="_cache_aligned_buffer_8h_source.html#l00108">CacheAlignedBuffer.h:108</a></div></div>
</div><!-- fragment --><p>This code will cause the data in <code>command</code> to be sent to the device and the response to be received into <code>response</code> . During the transfer, the current thread is paused, but other threads can execute. The non-blocking API does not pause the current thread, but is a bit more complicated to use. See the <a class="el" href="classmbed_1_1_s_p_i.html#a2aacbea21313b9ffc90cf79fcb2a91f9" title="Start SPI transfer and wait until it is complete.">SPI::transfer_and_wait()</a> implementation in SPI.cpp for an example.</p>
<h3>Async: DMA vs Interrupts</h3>
<p>Some processors only provide asynchronous SPI via interrupts, some only support DMA, and some offer both. Using interrupts is simpler and generally doesn't require additional resources from the chip, however, some CPU time will be spent servicing the interrupt while the transfer is running. This can become very performance-intensive &ndash; on some chips, running async SPI at frequencies of just a few MHz can be enough to make the interrupt use 100% of CPU time. In contrast, DMA can require additional resources to be allocated, (e.g. chips with few DMA channels might only support DMA on one or two SPI busses at a time), but can run the bus at full speed without any CPU overhead. Generally, DMA should be preferred if available, especially if medium to fast bus speeds are needed.</p>
<p>Consult your chip documentation and the Mbed port docs for your target to find out what is needed to enable DMA support. For example, for STMicro targets, see <a href="https://github.com/mbed-ce/mbed-os/wiki/STM32-DMA-SPI-Support">here</a>.To select DMA or interrupts, use the <a class="el" href="classmbed_1_1_s_p_i.html#a4885d525858929a6654d0da30dd77955" title="Configure DMA usage suggestion for non-blocking transfers.">SPI::set_dma_usage()</a> function. By default, interrupt SPI will be used unless you change the setting.</p>
<h3>Async: Queueing</h3>
<p>The async SPI system supports an optional transaction queueing mechanism. When this is enabled, Mbed will allow multiple transactions to be queued up on a single bus, and will execute each one and deliver the appropriate callback in series. This is mainly useful for the non-blocking async api (<a class="el" href="classmbed_1_1_s_p_i.html#a04175d1089a2e1ff86ca2f03f133864a" title="Start non-blocking SPI transfer.">SPI::transfer()</a>), though you can also use it with the blocking API by having multiple threads call it at once.</p>
<p>The transaction queue size defaults to 2 on most devices, but you can change that using the <code>drivers.spi_transaction_queue_len</code> option, e.g.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;target_overrides&quot;: {</div>
<div class="line">         &quot;*&quot;: {</div>
<div class="line">             &quot;drivers.spi_transaction_queue_len&quot;: 3</div>
<div class="line">         }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>To save a little bit of memory, you can also set the queue length to 0 to disable the queueing mechanism.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently, the value set by <a class="el" href="classmbed_1_1_s_p_i.html#a162d7008eb2691cb49f9f82796a63536" title="Set default write data.">SPI::set_default_write_value()</a> is <a href="https://github.com/ARMmbed/mbed-os/issues/13941">not respected</a> by the asynchronous SPI code. This needs to be fixed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_s_p_i_8h_source.html#l00266">266</a> of file <a class="el" href="_s_p_i_8h_source.html">SPI.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a21d684ae9ab826c863c3d198fb761bad" name="a21d684ae9ab826c863c3d198fb761bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d684ae9ab826c863c3d198fb761bad">&#9670;&#160;</a></span>SPI() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_s_p_i.html">SPI</a> </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>mosi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>miso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>sclk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>ssel</em> = <code>NC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> master connected to the specified pins. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor passes the SSEL pin selection to the target HAL. Not all targets support SSEL, so this cannot be relied on in portable code. Portable code should use the alternative constructor that uses GPIO for SSEL.</dd>
<dd>
You can specify mosi or miso as NC if not used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mosi</td><td><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Master Out, Slave In pin. </td></tr>
    <tr><td class="paramname">miso</td><td><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Master In, Slave Out pin. </td></tr>
    <tr><td class="paramname">sclk</td><td><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Clock pin. </td></tr>
    <tr><td class="paramname">ssel</td><td><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Chip Select pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0616bc0845ecebb978b0913bbe118262" name="a0616bc0845ecebb978b0913bbe118262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0616bc0845ecebb978b0913bbe118262">&#9670;&#160;</a></span>SPI() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_s_p_i.html">SPI</a> </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>mosi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>miso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>sclk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>ssel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmbed_1_1use__gpio__ssel__t.html">use_gpio_ssel_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> master connected to the specified pins. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor manipulates the SSEL pin as a GPIO output using a <a class="el" href="classmbed_1_1_digital_out.html" title="A digital output, used for setting the state of a pin.">DigitalOut</a> object. This should work on any target, and permits the use of <a class="el" href="classmbed_1_1_s_p_i.html#abc9e3e51760dbdc066b1d082e496719e" title="Assert the Slave Select line and acquire exclusive access to this SPI bus.">select()</a> and <a class="el" href="classmbed_1_1_s_p_i.html#a0ae77235b32f5522d5d881baf2c52210" title="Deassert the Slave Select line, releasing exclusive access to this SPI bus.">deselect()</a> methods to keep the pin asserted between transfers.</dd>
<dd>
You can specify mosi or miso as NC if not used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mosi</td><td><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Master Out, Slave In pin. </td></tr>
    <tr><td class="paramname">miso</td><td><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Master In, Slave Out pin. </td></tr>
    <tr><td class="paramname">sclk</td><td><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Clock pin. </td></tr>
    <tr><td class="paramname">ssel</td><td><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Chip Select pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab110082bbac4fc7d1a5ceb6942f4b5c0" name="ab110082bbac4fc7d1a5ceb6942f4b5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab110082bbac4fc7d1a5ceb6942f4b5c0">&#9670;&#160;</a></span>SPI() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_s_p_i.html">SPI</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspi__pinmap__t.html">spi_pinmap_t</a> &amp;&#160;</td>
          <td class="paramname"><em>static_pinmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> master connected to the specified pins. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor passes the SSEL pin selection to the target HAL. Not all targets support SSEL, so this cannot be relied on in portable code. Portable code should use the alternative constructor that uses GPIO for SSEL.</dd>
<dd>
You can specify mosi or miso as NC if not used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">static_pinmap</td><td>reference to structure which holds static pinmap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b90429f64efdd3708234ddcc051a7c7" name="a3b90429f64efdd3708234ddcc051a7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b90429f64efdd3708234ddcc051a7c7">&#9670;&#160;</a></span>SPI() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_s_p_i.html">SPI</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspi__pinmap__t.html">spi_pinmap_t</a> &amp;&#160;</td>
          <td class="paramname"><em>static_pinmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>ssel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> master connected to the specified pins. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor manipulates the SSEL pin as a GPIO output using a <a class="el" href="classmbed_1_1_digital_out.html" title="A digital output, used for setting the state of a pin.">DigitalOut</a> object. This should work on any target, and permits the use of <a class="el" href="classmbed_1_1_s_p_i.html#abc9e3e51760dbdc066b1d082e496719e" title="Assert the Slave Select line and acquire exclusive access to this SPI bus.">select()</a> and <a class="el" href="classmbed_1_1_s_p_i.html#a0ae77235b32f5522d5d881baf2c52210" title="Deassert the Slave Select line, releasing exclusive access to this SPI bus.">deselect()</a> methods to keep the pin asserted between transfers.</dd>
<dd>
You can specify mosi or miso as NC if not used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">static_pinmap</td><td>reference to structure which holds static pinmap. </td></tr>
    <tr><td class="paramname">ssel</td><td><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Chip Select pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7627faa611c3645626b6b627755fcae7" name="a7627faa611c3645626b6b627755fcae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7627faa611c3645626b6b627755fcae7">&#9670;&#160;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the data transmission format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>Number of bits per SPI frame (4 - 32, target dependent). </td></tr>
    <tr><td class="paramname">mode</td><td>Clock polarity and phase mode (0 - 3).</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">mode | POL PHA</div>
<div class="line">-----+--------</div>
<div class="line">  0  |  0   0</div>
<div class="line">  1  |  0   1</div>
<div class="line">  2  |  1   0</div>
<div class="line">  3  |  1   1</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4426901f2bcededa2ae9c5e6547b9a2a" name="a4426901f2bcededa2ae9c5e6547b9a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4426901f2bcededa2ae9c5e6547b9a2a">&#9670;&#160;</a></span>frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void frequency </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hz</em> = <code>1000000</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the SPI bus clock frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hz</td><td>Clock frequency in Hz (default = 1MHz). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a594e0eb0068da0fdc3d57e2d018c1994" name="a594e0eb0068da0fdc3d57e2d018c1994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594e0eb0068da0fdc3d57e2d018c1994">&#9670;&#160;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to the SPI Slave and return the response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Data to be sent to the <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> slave. The number of significant bits in this value depend on the <code>bits</code> parameter to <a class="el" href="classmbed_1_1_s_p_i.html#a7627faa611c3645626b6b627755fcae7" title="Configure the data transmission format.">format()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Response from the SPI slave. The number of significant bits in this value depend on the <code>bits</code> parameter to <a class="el" href="classmbed_1_1_s_p_i.html#a7627faa611c3645626b6b627755fcae7" title="Configure the data transmission format.">format()</a>. </dd></dl>

</div>
</div>
<a id="a18f3e630e7940255c89f170afd657c7e" name="a18f3e630e7940255c89f170afd657c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f3e630e7940255c89f170afd657c7e">&#9670;&#160;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WordT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; WordT &gt;::value, int &gt;::type write </td>
          <td>(</td>
          <td class="paramtype">const WordT *&#160;</td>
          <td class="paramname"><em>tx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WordT *&#160;</td>
          <td class="paramname"><em>rx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> Slave and obtain the response. </p>
<p>The total number of bytes sent and received will be the maximum of tx_length and rx_length. The bytes written will be padded with the value 0xff.</p>
<p>Note: Even if the word size / bits per frame is not 8, <code>rx_length</code> and <code>tx_length</code> still count bytes of input data, not numbers of words.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_buffer</td><td>Pointer to the byte-array of data to write to the device. </td></tr>
    <tr><td class="paramname">tx_length</td><td>Number of bytes to write, may be zero. </td></tr>
    <tr><td class="paramname">rx_buffer</td><td>Pointer to the byte-array of data to read from the device. </td></tr>
    <tr><td class="paramname">rx_length</td><td>Number of bytes to read, may be zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written and read from the device (as an int). This is maximum of tx_length and rx_length. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_s_p_i_8h_source.html#l00388">388</a> of file <a class="el" href="_s_p_i_8h_source.html">SPI.h</a>.</p>

</div>
</div>
<a id="ad67df83ace240f53c1276e24a37ff84c" name="ad67df83ace240f53c1276e24a37ff84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67df83ace240f53c1276e24a37ff84c">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire exclusive access to this <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus. </p>
<p>This function blocks until the chosen <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> peripheral is not being used by any other <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> objects. Careful &ndash; if other code leaves the bus locked, this could block forever! </p>

</div>
</div>
<a id="a5d882b4e464e4f4bd59eab6c75297bda" name="a5d882b4e464e4f4bd59eab6c75297bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d882b4e464e4f4bd59eab6c75297bda">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release exclusive access to this <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus. </p>
<p>This allows other code to do operations using the <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> peripheral. </p>

</div>
</div>
<a id="abc9e3e51760dbdc066b1d082e496719e" name="abc9e3e51760dbdc066b1d082e496719e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9e3e51760dbdc066b1d082e496719e">&#9670;&#160;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert the Slave Select line and acquire exclusive access to this <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus. </p>
<p>The slave select line will remain selected (low) for all following operations until you call <a class="el" href="classmbed_1_1_s_p_i.html#a0ae77235b32f5522d5d881baf2c52210" title="Deassert the Slave Select line, releasing exclusive access to this SPI bus.">deselect()</a> on this instance. This allows you to string together multiple <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> transactions as if they were a single operation (from the perspective of peripheral chips).</p>
<p>If use_gpio_ssel was not passed to the constructor, manual control of the SSEL line is not possible, and this function behaves identically to <a class="el" href="classmbed_1_1_s_p_i.html#ad67df83ace240f53c1276e24a37ff84c" title="Acquire exclusive access to this SPI bus.">lock()</a>.</p>
<p>Like <a class="el" href="classmbed_1_1_s_p_i.html#ad67df83ace240f53c1276e24a37ff84c" title="Acquire exclusive access to this SPI bus.">lock()</a>, this function will block until exclusive access can be acquired.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function while an asynchronous transfer is in progress, as undefined behavior can occur. </dd></dl>

</div>
</div>
<a id="a0ae77235b32f5522d5d881baf2c52210" name="a0ae77235b32f5522d5d881baf2c52210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae77235b32f5522d5d881baf2c52210">&#9670;&#160;</a></span>deselect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deselect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deassert the Slave Select line, releasing exclusive access to this <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> bus. </p>
<p>If use_gpio_ssel was not passed to the constructor, manual control of the SSEL line is not possible, and this function behaves identically to <a class="el" href="classmbed_1_1_s_p_i.html#a5d882b4e464e4f4bd59eab6c75297bda" title="Release exclusive access to this SPI bus.">unlock()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function while an asynchronous transfer is in progress, as undefined behavior can occur. </dd></dl>

</div>
</div>
<a id="a162d7008eb2691cb49f9f82796a63536" name="a162d7008eb2691cb49f9f82796a63536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162d7008eb2691cb49f9f82796a63536">&#9670;&#160;</a></span>set_default_write_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_default_write_value </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default write data. </p>
<p><a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> requires the master to send some data during a read operation. Different devices may require different default byte values. For example: A SD Card requires default bytes to be 0xFF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Default character to be transmitted during a read operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04175d1089a2e1ff86ca2f03f133864a" name="a04175d1089a2e1ff86ca2f03f133864a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04175d1089a2e1ff86ca2f03f133864a">&#9670;&#160;</a></span>transfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WordT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; WordT &gt;::value, int &gt;::type transfer </td>
          <td>(</td>
          <td class="paramtype">const WordT *&#160;</td>
          <td class="paramname"><em>tx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_cache_aligned_buffer.html">CacheAlignedBuffer</a>&lt; WordT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em> = <code><a class="el" href="group__hal___s_p_i_events.html#ga84a652fdfd9732b4d6348443374603e4">SPI_EVENT_COMPLETE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start non-blocking SPI transfer. </p>
<p>This function locks the deep sleep until any event has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_buffer</td><td>The TX buffer with data to be transferred. If NULL is passed, the default SPI value is sent. </td></tr>
    <tr><td class="paramname">tx_length</td><td>The length of TX buffer in bytes. </td></tr>
    <tr><td class="paramname">rx_buffer</td><td>The RX buffer which is used for received data. Rather than a C array, a <a class="el" href="classmbed_1_1_cache_aligned_buffer.html" title="CacheAlignedBuffer is used by Mbed in locations where we need a cache-aligned buffer.">CacheAlignedBuffer</a> structure must be passed so that cache alignment can be handled for data received from DMA. May be nullptr if rx_length is 0. </td></tr>
    <tr><td class="paramname">rx_length</td><td>The length of RX buffer in bytes. </td></tr>
    <tr><td class="paramname">callback</td><td>The event callback function. </td></tr>
    <tr><td class="paramname">event</td><td>The logical OR of events to subscribe to. May be <a class="el" href="group__hal___s_p_i_events.html#ga28965522566c2b9b99aa6b51a8b2c627" title="Union of all of the above events.">SPI_EVENT_ALL</a>, or some combination of the flags <a class="el" href="group__hal___s_p_i_events.html#ga29c24d16ec62e5f385697100b0a86388" title="Indicates that some kind of error occurred when starting the transfer.">SPI_EVENT_ERROR</a>, <a class="el" href="group__hal___s_p_i_events.html#ga84a652fdfd9732b4d6348443374603e4" title="Indicates that the transfer completed successfully.">SPI_EVENT_COMPLETE</a>, or <a class="el" href="group__hal___s_p_i_events.html#ga85415f6cfde29f7bcc1ebebc8cb70acc" title="Indicates an Rx overflow: the interrupt system or DMA controller was not able to keep up with the flo...">SPI_EVENT_RX_OVERFLOW</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result (integer) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If the transfer has started. </td></tr>
    <tr><td class="paramname">-1</td><td>if the transfer could not be enqueued (increase drivers.spi_transaction_queue_len option) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_s_p_i_8h_source.html#l00484">484</a> of file <a class="el" href="_s_p_i_8h_source.html">SPI.h</a>.</p>

</div>
</div>
<a id="a2aacbea21313b9ffc90cf79fcb2a91f9" name="a2aacbea21313b9ffc90cf79fcb2a91f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aacbea21313b9ffc90cf79fcb2a91f9">&#9670;&#160;</a></span>transfer_and_wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WordT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; WordT &gt;::value, int &gt;::type transfer_and_wait </td>
          <td>(</td>
          <td class="paramtype">const WordT *&#160;</td>
          <td class="paramname"><em>tx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_cache_aligned_buffer.html">CacheAlignedBuffer</a>&lt; WordT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtos::Kernel::Clock::duration_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="namespacertos_1_1_kernel.html#a29baed0762de3912b6b7592150a9498e">rtos::Kernel::wait_for_u32_forever</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start SPI transfer and wait until it is complete. </p>
<p>Like the transactional API this blocks the current thread, however all work is done in the background and other threads may execute.</p>
<p>As long as there is space, this function will enqueue the transfer request onto the peripheral, and block until it is done.</p>
<p>Internally, the chip vendor may implement this function using either DMA or interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_buffer</td><td>The TX buffer with data to be transferred. May be nullptr if tx_length is 0. </td></tr>
    <tr><td class="paramname">tx_length</td><td>The length of TX buffer in bytes. If 0, the default SPI data value is sent when receiving data. </td></tr>
    <tr><td class="paramname">rx_buffer</td><td>The RX buffer which is used for received data. Rather than a C array, a <a class="el" href="classmbed_1_1_cache_aligned_buffer.html" title="CacheAlignedBuffer is used by Mbed in locations where we need a cache-aligned buffer.">CacheAlignedBuffer</a> structure must be passed so that cache alignment can be handled for data received from DMA. May be nullptr if rx_length is 0. </td></tr>
    <tr><td class="paramname">rx_length</td><td>The length of RX buffer in bytes If 0, no reception is done. </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value. Use <a class="el" href="namespacertos_1_1_kernel.html#a29baed0762de3912b6b7592150a9498e" title="Magic &quot;wait forever&quot; constant for Kernel::Clock::duration_u32-based APIs.">rtos::Kernel::wait_for_u32_forever</a> to wait forever (the default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result (integer) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the transfer could not be enqueued (increase drivers.spi_transaction_queue_len option) </td></tr>
    <tr><td class="paramname">1</td><td>on timeout </td></tr>
    <tr><td class="paramname">2</td><td>on other error </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_s_p_i_8h_source.html#l00532">532</a> of file <a class="el" href="_s_p_i_8h_source.html">SPI.h</a>.</p>

</div>
</div>
<a id="a90253410d768f60403698f5f383d1931" name="a90253410d768f60403698f5f383d1931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90253410d768f60403698f5f383d1931">&#9670;&#160;</a></span>abort_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abort_transfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort the on-going <a class="el" href="classmbed_1_1_s_p_i.html" title="An SPI Master, used for communicating with SPI slave devices.">SPI</a> transfer, if any, and continue with transfers in the queue, if any. </p>
<dl class="section note"><dt>Note</dt><dd>If a transfer is aborted, its callback will not be called at all. </dd></dl>

</div>
</div>
<a id="aad7b4dd10bf4f4bb5eab6bdd11cebd44" name="aad7b4dd10bf4f4bb5eab6bdd11cebd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7b4dd10bf4f4bb5eab6bdd11cebd44">&#9670;&#160;</a></span>clear_transfer_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_transfer_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the queue of transfers. </p>
<p>If a transfer is currently active, it will continue until complete. </p>

</div>
</div>
<a id="a7787a47c785a57ddd0307add8be643e1" name="a7787a47c785a57ddd0307add8be643e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7787a47c785a57ddd0307add8be643e1">&#9670;&#160;</a></span>abort_all_transfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abort_all_transfers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the queue of transfers and abort any on-going transfer. </p>

</div>
</div>
<a id="a4885d525858929a6654d0da30dd77955" name="a4885d525858929a6654d0da30dd77955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4885d525858929a6654d0da30dd77955">&#9670;&#160;</a></span>set_dma_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int set_dma_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal.html#ga9fb5be593465bb507b7bc23945ddf30c">DMAUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure DMA usage suggestion for non-blocking transfers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usage</td><td>The usage DMA hint for peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The usage was set. </td></tr>
    <tr><td class="paramname">-1</td><td>Usage cannot be set as there is an ongoing transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mbed</b></li><li class="navelem"><a class="el" href="classmbed_1_1_s_p_i.html">SPI</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
