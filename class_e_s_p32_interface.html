<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: ESP32Interface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_e_s_p32_interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">ESP32Interface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> class Implementation of the <a class="el" href="class_network_stack.html" title="NetworkStack class.">NetworkStack</a> for the ESP32.  
 <a href="class_e_s_p32_interface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_e_s_p32_interface_8h_source.html">ESP32Interface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ESP32Interface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_e_s_p32_interface.png" usemap="#ESP32Interface_map" alt=""/>
  <map id="ESP32Interface_map" name="ESP32Interface_map">
<area href="class_e_s_p32_stack.html" title="ESP32Stack class Implementation of the NetworkStack for the ESP32." alt="ESP32Stack" shape="rect" coords="0,112,108,136"/>
<area href="class_wi_fi_interface.html" title="Common interface between Wi-Fi devices." alt="WiFiInterface" shape="rect" coords="118,112,226,136"/>
<area href="class_network_stack.html" title="NetworkStack class." alt="NetworkStack" shape="rect" coords="0,56,108,80"/>
<area href="class_network_interface.html" title="Common interface that is shared between network devices." alt="NetworkInterface" shape="rect" coords="118,56,226,80"/>
<area href="class_d_n_s.html" title="Base class for DNS provider." alt="DNS" shape="rect" coords="0,0,108,24"/>
<area href="class_d_n_s.html" title="Base class for DNS provider." alt="DNS" shape="rect" coords="118,0,226,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7640d35fa5798e1ff5ce0cf9a7faa097" id="r_a7640d35fa5798e1ff5ce0cf9a7faa097"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>(int delay_ms, <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void()&gt; user_cb)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a7640d35fa5798e1ff5ce0cf9a7faa097">call_in_callback_cb_t</a></td></tr>
<tr class="memdesc:a7640d35fa5798e1ff5ce0cf9a7faa097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a call-in callback.  <br /></td></tr>
<tr class="separator:a7640d35fa5798e1ff5ce0cf9a7faa097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb962f363d7a7ec29b27844a1e5f7ecc" id="r_abb962f363d7a7ec29b27844a1e5f7ecc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(<a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> result, <a class="el" href="class_socket_address.html">SocketAddress</a> *address)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a></td></tr>
<tr class="memdesc:abb962f363d7a7ec29b27844a1e5f7ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hostname translation callback (for use with <a class="el" href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7" title="Translate a hostname to an IP address (asynchronous) using network interface name.">gethostbyname_async()</a>).  <br /></td></tr>
<tr class="separator:abb962f363d7a7ec29b27844a1e5f7ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53e7a6b756107d4ab01a7efbfabb74d3" id="r_a53e7a6b756107d4ab01a7efbfabb74d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a53e7a6b756107d4ab01a7efbfabb74d3">ESP32Interface</a> ()</td></tr>
<tr class="memdesc:a53e7a6b756107d4ab01a7efbfabb74d3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> lifetime Configuration defined in mbed_lib.json.  <br /></td></tr>
<tr class="separator:a53e7a6b756107d4ab01a7efbfabb74d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f422971062c7154ef1b61b6388f6765" id="r_a8f422971062c7154ef1b61b6388f6765"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a8f422971062c7154ef1b61b6388f6765">ESP32Interface</a> (PinName en, PinName io0, PinName tx, PinName rx, bool debug=false, PinName rts=NC, PinName cts=NC, int baudrate=230400)</td></tr>
<tr class="memdesc:a8f422971062c7154ef1b61b6388f6765"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> lifetime.  <br /></td></tr>
<tr class="separator:a8f422971062c7154ef1b61b6388f6765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94acf89498ebbfdc57eaa3d8435fdaa6" id="r_a94acf89498ebbfdc57eaa3d8435fdaa6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a94acf89498ebbfdc57eaa3d8435fdaa6">~ESP32Interface</a> () override</td></tr>
<tr class="memdesc:a94acf89498ebbfdc57eaa3d8435fdaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> default destructor.  <br /></td></tr>
<tr class="separator:a94acf89498ebbfdc57eaa3d8435fdaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b789bec3883332ef9d49b07f2f7c61d" id="r_a9b789bec3883332ef9d49b07f2f7c61d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a9b789bec3883332ef9d49b07f2f7c61d">ESP32Interface</a> (PinName tx, PinName rx, bool debug=false)</td></tr>
<tr class="memdesc:a9b789bec3883332ef9d49b07f2f7c61d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> lifetime.  <br /></td></tr>
<tr class="separator:a9b789bec3883332ef9d49b07f2f7c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9919ef603c0c526ec73722610bd877ca" id="r_a9919ef603c0c526ec73722610bd877ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a9919ef603c0c526ec73722610bd877ca">set_network</a> (const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;ip_address, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;netmask, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;gateway) override</td></tr>
<tr class="memdesc:a9919ef603c0c526ec73722610bd877ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this network interface to use a static IP address.  <br /></td></tr>
<tr class="separator:a9919ef603c0c526ec73722610bd877ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e39d3de385c6227267f23666ea86eb3" id="r_a8e39d3de385c6227267f23666ea86eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a8e39d3de385c6227267f23666ea86eb3">set_dhcp</a> (bool dhcp) override</td></tr>
<tr class="memdesc:a8e39d3de385c6227267f23666ea86eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable DHCP on connecting the network.  <br /></td></tr>
<tr class="separator:a8e39d3de385c6227267f23666ea86eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3eb3944219908ecdae29dfaea47656" id="r_a8e3eb3944219908ecdae29dfaea47656"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a8e3eb3944219908ecdae29dfaea47656">connect</a> () override</td></tr>
<tr class="memdesc:a8e3eb3944219908ecdae29dfaea47656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect to a Wi-Fi network.  <br /></td></tr>
<tr class="separator:a8e3eb3944219908ecdae29dfaea47656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abe553131db3322747534c21ef921aa" id="r_a6abe553131db3322747534c21ef921aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a6abe553131db3322747534c21ef921aa">connect</a> (const char *ssid, const char *pass, <a class="el" href="group___net_socket.html#ga022366557c25927ba58a66197c1e813b">nsapi_security_t</a> security=<a class="el" href="group___net_socket.html#gga0bfcdf6a9abae30715b5e7f43ae4a0c5a54dc678bd03b26b31588ca37aee6c713">NSAPI_SECURITY_NONE</a>, uint8_t channel=0) override</td></tr>
<tr class="memdesc:a6abe553131db3322747534c21ef921aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect to a Wi-Fi network.  <br /></td></tr>
<tr class="separator:a6abe553131db3322747534c21ef921aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673ad5763bd4caf275960bfcd2f44419" id="r_a673ad5763bd4caf275960bfcd2f44419"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a673ad5763bd4caf275960bfcd2f44419">set_credentials</a> (const char *ssid, const char *pass, <a class="el" href="group___net_socket.html#ga022366557c25927ba58a66197c1e813b">nsapi_security_t</a> security=<a class="el" href="group___net_socket.html#gga0bfcdf6a9abae30715b5e7f43ae4a0c5a54dc678bd03b26b31588ca37aee6c713">NSAPI_SECURITY_NONE</a>) override</td></tr>
<tr class="memdesc:a673ad5763bd4caf275960bfcd2f44419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Wi-Fi network credentials.  <br /></td></tr>
<tr class="separator:a673ad5763bd4caf275960bfcd2f44419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc78fca8fe9cf20f5ed56aefe983613" id="r_afbc78fca8fe9cf20f5ed56aefe983613"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#afbc78fca8fe9cf20f5ed56aefe983613">set_channel</a> (uint8_t channel) override</td></tr>
<tr class="memdesc:afbc78fca8fe9cf20f5ed56aefe983613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Wi-Fi network channel.  <br /></td></tr>
<tr class="separator:afbc78fca8fe9cf20f5ed56aefe983613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5b7c7b173b315e777e384245ca2a13" id="r_acd5b7c7b173b315e777e384245ca2a13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#acd5b7c7b173b315e777e384245ca2a13">disconnect</a> () override</td></tr>
<tr class="memdesc:acd5b7c7b173b315e777e384245ca2a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the interface.  <br /></td></tr>
<tr class="separator:acd5b7c7b173b315e777e384245ca2a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1b72fe745784e4f851ce9c59fb4536" id="r_a3d1b72fe745784e4f851ce9c59fb4536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a3d1b72fe745784e4f851ce9c59fb4536">get_ip_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *sockAddr) override</td></tr>
<tr class="memdesc:a3d1b72fe745784e4f851ce9c59fb4536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP address.  <br /></td></tr>
<tr class="separator:a3d1b72fe745784e4f851ce9c59fb4536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3eff5846155587cbfbc854c1203d16" id="r_a1d3eff5846155587cbfbc854c1203d16"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a1d3eff5846155587cbfbc854c1203d16">get_mac_address</a> () override</td></tr>
<tr class="memdesc:a1d3eff5846155587cbfbc854c1203d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local MAC address.  <br /></td></tr>
<tr class="separator:a1d3eff5846155587cbfbc854c1203d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daefe15c491142d649cc33382372c68" id="r_a4daefe15c491142d649cc33382372c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a4daefe15c491142d649cc33382372c68">get_gateway</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *sockAddr) override</td></tr>
<tr class="memdesc:a4daefe15c491142d649cc33382372c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local gateway.  <br /></td></tr>
<tr class="separator:a4daefe15c491142d649cc33382372c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ba6febc74251569b88acfabaa08948" id="r_a67ba6febc74251569b88acfabaa08948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a67ba6febc74251569b88acfabaa08948">get_netmask</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *sockAddr) override</td></tr>
<tr class="memdesc:a67ba6febc74251569b88acfabaa08948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local network mask.  <br /></td></tr>
<tr class="separator:a67ba6febc74251569b88acfabaa08948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856cd17a1511857c58afdeb59b16591b" id="r_a856cd17a1511857c58afdeb59b16591b"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a856cd17a1511857c58afdeb59b16591b">get_rssi</a> () override</td></tr>
<tr class="memdesc:a856cd17a1511857c58afdeb59b16591b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current radio signal strength for active connection.  <br /></td></tr>
<tr class="separator:a856cd17a1511857c58afdeb59b16591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2033b4f0a88ffc36eb43c11f3dba6" id="r_a91f2033b4f0a88ffc36eb43c11f3dba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a91f2033b4f0a88ffc36eb43c11f3dba6">attach</a> (<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt; status_cb) override</td></tr>
<tr class="memdesc:a91f2033b4f0a88ffc36eb43c11f3dba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callback for status reporting.  <br /></td></tr>
<tr class="separator:a91f2033b4f0a88ffc36eb43c11f3dba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba659ec308e54e6b45efb55b4195e95" id="r_a2ba659ec308e54e6b45efb55b4195e95"><td class="memItemLeft" align="right" valign="top">nsapi_connection_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a2ba659ec308e54e6b45efb55b4195e95">get_connection_status</a> () const override</td></tr>
<tr class="memdesc:a2ba659ec308e54e6b45efb55b4195e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the connection status.  <br /></td></tr>
<tr class="separator:a2ba659ec308e54e6b45efb55b4195e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeb3e01ec53546b61fd7b823a4980ef" id="r_a5eeb3e01ec53546b61fd7b823a4980ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a5eeb3e01ec53546b61fd7b823a4980ef">gethostbyname</a> (const char *host, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, nsapi_version_t version=<a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to an IP address with specific version using network interface name.  <br /></td></tr>
<tr class="separator:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260338652be8fba7b1004bc924fdb781" id="r_a260338652be8fba7b1004bc924fdb781"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_interface.html#a260338652be8fba7b1004bc924fdb781">add_dns_server</a> (const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const char *interface_name)</td></tr>
<tr class="memdesc:a260338652be8fba7b1004bc924fdb781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a domain name server to list of servers to query.  <br /></td></tr>
<tr class="separator:a260338652be8fba7b1004bc924fdb781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77de8d1afa4b83dd6f560dc39251e1eb" id="r_a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a77de8d1afa4b83dd6f560dc39251e1eb">get_ipv6_link_local_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IPv6 link local address.  <br /></td></tr>
<tr class="separator:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad597f0496e42b17be72d00fa832e0963" id="r_ad597f0496e42b17be72d00fa832e0963"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#ad597f0496e42b17be72d00fa832e0963">get_ip_address_if</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address, const char *interface_name)</td></tr>
<tr class="memdesc:ad597f0496e42b17be72d00fa832e0963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP address on interface name.  <br /></td></tr>
<tr class="separator:ad597f0496e42b17be72d00fa832e0963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a975b9ef736cef63334895c5770660" id="r_a87a975b9ef736cef63334895c5770660"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a87a975b9ef736cef63334895c5770660">getaddrinfo</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_socket_address.html">SocketAddress</a> **res, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a87a975b9ef736cef63334895c5770660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to the multiple IP addresses with specific version using network interface name.  <br /></td></tr>
<tr class="separator:a87a975b9ef736cef63334895c5770660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43b64cae1f145615db7f697d34552d7" id="r_ab43b64cae1f145615db7f697d34552d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#ab43b64cae1f145615db7f697d34552d7">gethostbyname_async</a> (const char *host, <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a> callback, nsapi_version_t version=<a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:ab43b64cae1f145615db7f697d34552d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a hostname to multiple IP addresses (asynchronous)  <br /></td></tr>
<tr class="separator:ab43b64cae1f145615db7f697d34552d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964732e6c585b596adc760fe95f40f5" id="r_aa964732e6c585b596adc760fe95f40f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aa964732e6c585b596adc760fe95f40f5">getaddrinfo_async</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a> callback, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:aa964732e6c585b596adc760fe95f40f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a hostname to the multiple IP addresses (asynchronous)  <br /></td></tr>
<tr class="separator:aa964732e6c585b596adc760fe95f40f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26000e958701f5b35886fac1757c0bf4" id="r_a26000e958701f5b35886fac1757c0bf4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a26000e958701f5b35886fac1757c0bf4">gethostbyname_async_cancel</a> (int id)</td></tr>
<tr class="memdesc:a26000e958701f5b35886fac1757c0bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels asynchronous hostname translation.  <br /></td></tr>
<tr class="separator:a26000e958701f5b35886fac1757c0bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccb0f7a5af95e76d0dea335ab866047" id="r_a0ccb0f7a5af95e76d0dea335ab866047"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a0ccb0f7a5af95e76d0dea335ab866047">get_dns_server</a> (int index, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a0ccb0f7a5af95e76d0dea335ab866047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a domain name server from a list of servers to query.  <br /></td></tr>
<tr class="separator:a0ccb0f7a5af95e76d0dea335ab866047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f46dd32614b93bc8a9d41b822a7ab7" id="r_aa5f46dd32614b93bc8a9d41b822a7ab7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_onboard_network_stack.html">OnboardNetworkStack</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aa5f46dd32614b93bc8a9d41b822a7ab7">onboardNetworkStack</a> ()</td></tr>
<tr class="memdesc:aa5f46dd32614b93bc8a9d41b822a7ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic downcast to a <a class="el" href="class_onboard_network_stack.html" title="mbed OS API for onboard IP stack abstraction">OnboardNetworkStack</a>.  <br /></td></tr>
<tr class="separator:aa5f46dd32614b93bc8a9d41b822a7ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8fee7fdad17ce5709afd57cf51743a" id="r_afc8fee7fdad17ce5709afd57cf51743a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wi_fi_interface.html#afc8fee7fdad17ce5709afd57cf51743a">scan</a> (<a class="el" href="class_wi_fi_access_point.html">WiFiAccessPoint</a> *res, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> count)=0</td></tr>
<tr class="memdesc:afc8fee7fdad17ce5709afd57cf51743a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for available networks.  <br /></td></tr>
<tr class="separator:afc8fee7fdad17ce5709afd57cf51743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47da289e164960eaeea7f2a4d155003" id="r_ac47da289e164960eaeea7f2a4d155003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wi_fi_interface.html">WiFiInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wi_fi_interface.html#ac47da289e164960eaeea7f2a4d155003">wifiInterface</a> () final</td></tr>
<tr class="memdesc:ac47da289e164960eaeea7f2a4d155003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_wi_fi_interface.html" title="Common interface between Wi-Fi devices.">WiFiInterface</a>.    <br /></td></tr>
<tr class="separator:ac47da289e164960eaeea7f2a4d155003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e37f9f2a19ab17cc5c7baebf6293de" id="r_a68e37f9f2a19ab17cc5c7baebf6293de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wi_fi_interface.html#a68e37f9f2a19ab17cc5c7baebf6293de">set_default_parameters</a> () override</td></tr>
<tr class="memdesc:a68e37f9f2a19ab17cc5c7baebf6293de"><td class="mdescLeft">&#160;</td><td class="mdescRight">defined(DOXYGEN_ONLY)  <br /></td></tr>
<tr class="separator:a68e37f9f2a19ab17cc5c7baebf6293de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a94b10f0ae842556ebb0e0775b557cb" id="r_a4a94b10f0ae842556ebb0e0775b557cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a4a94b10f0ae842556ebb0e0775b557cb">set_as_default</a> ()</td></tr>
<tr class="memdesc:a4a94b10f0ae842556ebb0e0775b557cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set network interface as default one.  <br /></td></tr>
<tr class="separator:a4a94b10f0ae842556ebb0e0775b557cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ea7f00483d172baf3a98f3ca2bab2a" id="r_a42ea7f00483d172baf3a98f3ca2bab2a"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a42ea7f00483d172baf3a98f3ca2bab2a">get_hostname</a> ()</td></tr>
<tr class="memdesc:a42ea7f00483d172baf3a98f3ca2bab2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hostname.  <br /></td></tr>
<tr class="separator:a42ea7f00483d172baf3a98f3ca2bab2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c52a8dbbacfc52ee1a255c156ed569" id="r_a26c52a8dbbacfc52ee1a255c156ed569"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a26c52a8dbbacfc52ee1a255c156ed569">set_hostname</a> (const char *hostname)</td></tr>
<tr class="memdesc:a26c52a8dbbacfc52ee1a255c156ed569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hostname.  <br /></td></tr>
<tr class="separator:a26c52a8dbbacfc52ee1a255c156ed569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526802de6e27e291d46e3e3e6a396978" id="r_a526802de6e27e291d46e3e3e6a396978"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a526802de6e27e291d46e3e3e6a396978">set_mac_address</a> (uint8_t *mac_addr, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> addr_len)</td></tr>
<tr class="memdesc:a526802de6e27e291d46e3e3e6a396978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MAC address to the interface.  <br /></td></tr>
<tr class="separator:a526802de6e27e291d46e3e3e6a396978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77de8d1afa4b83dd6f560dc39251e1eb" id="r_a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a77de8d1afa4b83dd6f560dc39251e1eb">get_ipv6_link_local_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IPv6 link local address.  <br /></td></tr>
<tr class="separator:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241ab3896730d179348de54e86dcd36c" id="r_a241ab3896730d179348de54e86dcd36c"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a241ab3896730d179348de54e86dcd36c">get_interface_name</a> (char *interface_name)</td></tr>
<tr class="memdesc:a241ab3896730d179348de54e86dcd36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the network interface name.  <br /></td></tr>
<tr class="separator:a241ab3896730d179348de54e86dcd36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a975b9ef736cef63334895c5770660" id="r_a87a975b9ef736cef63334895c5770660"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a87a975b9ef736cef63334895c5770660">getaddrinfo</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_socket_address.html">SocketAddress</a> **res, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a87a975b9ef736cef63334895c5770660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to the multiple IP addresses with specific version using network interface name.  <br /></td></tr>
<tr class="separator:a87a975b9ef736cef63334895c5770660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43b64cae1f145615db7f697d34552d7" id="r_ab43b64cae1f145615db7f697d34552d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7">gethostbyname_async</a> (const char *host, <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a> callback, nsapi_version_t version=<a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:ab43b64cae1f145615db7f697d34552d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to an IP address (asynchronous) using network interface name.  <br /></td></tr>
<tr class="separator:ab43b64cae1f145615db7f697d34552d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964732e6c585b596adc760fe95f40f5" id="r_aa964732e6c585b596adc760fe95f40f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#aa964732e6c585b596adc760fe95f40f5">getaddrinfo_async</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a> callback, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:aa964732e6c585b596adc760fe95f40f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to the multiple IP addresses (asynchronous) using network interface name.  <br /></td></tr>
<tr class="separator:aa964732e6c585b596adc760fe95f40f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26000e958701f5b35886fac1757c0bf4" id="r_a26000e958701f5b35886fac1757c0bf4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a26000e958701f5b35886fac1757c0bf4">gethostbyname_async_cancel</a> (int id)</td></tr>
<tr class="memdesc:a26000e958701f5b35886fac1757c0bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel asynchronous hostname translation.  <br /></td></tr>
<tr class="separator:a26000e958701f5b35886fac1757c0bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccb0f7a5af95e76d0dea335ab866047" id="r_a0ccb0f7a5af95e76d0dea335ab866047"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a0ccb0f7a5af95e76d0dea335ab866047">get_dns_server</a> (int index, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a0ccb0f7a5af95e76d0dea335ab866047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a domain name server from a list of servers to query.  <br /></td></tr>
<tr class="separator:a0ccb0f7a5af95e76d0dea335ab866047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61fc4dcb3f255e327c189325eee1e43" id="r_ab61fc4dcb3f255e327c189325eee1e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ab61fc4dcb3f255e327c189325eee1e43">add_event_listener</a> (<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt; status_cb)</td></tr>
<tr class="memdesc:ab61fc4dcb3f255e327c189325eee1e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add event listener for interface.  <br /></td></tr>
<tr class="separator:ab61fc4dcb3f255e327c189325eee1e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc0651d23c76c830d241236e22f0a1b" id="r_a8dc0651d23c76c830d241236e22f0a1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a8dc0651d23c76c830d241236e22f0a1b">set_blocking</a> (bool blocking)</td></tr>
<tr class="memdesc:a8dc0651d23c76c830d241236e22f0a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set asynchronous operation of <a class="el" href="class_network_interface.html#aaf6bf1dfffbe6a5626b7b52eaa542b6e" title="Connect to a network.">connect()</a> and <a class="el" href="class_network_interface.html#afdda3f62c7d73df183ee2d352e8cd146" title="Disconnect from the network.">disconnect()</a> calls.  <br /></td></tr>
<tr class="separator:a8dc0651d23c76c830d241236e22f0a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb296eec26bfad22eb94c71c9c502d" id="r_ad3fb296eec26bfad22eb94c71c9c502d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_eth_interface.html">EthInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ad3fb296eec26bfad22eb94c71c9c502d">ethInterface</a> ()</td></tr>
<tr class="memdesc:ad3fb296eec26bfad22eb94c71c9c502d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to an <a class="el" href="class_eth_interface.html" title="Common interface between Ethernet hardware.">EthInterface</a>.  <br /></td></tr>
<tr class="separator:ad3fb296eec26bfad22eb94c71c9c502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c1b846fba9d9008dafa54b31d4e1a0" id="r_a65c1b846fba9d9008dafa54b31d4e1a0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mesh_interface.html">MeshInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a65c1b846fba9d9008dafa54b31d4e1a0">meshInterface</a> ()</td></tr>
<tr class="memdesc:a65c1b846fba9d9008dafa54b31d4e1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_mesh_interface.html" title="Common interface that is shared between mesh hardware.">MeshInterface</a>.  <br /></td></tr>
<tr class="separator:a65c1b846fba9d9008dafa54b31d4e1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0ecf739088a765ebc7fbc4181bb375" id="r_ada0ecf739088a765ebc7fbc4181bb375"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_e_m_a_c_interface.html">EMACInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ada0ecf739088a765ebc7fbc4181bb375">emacInterface</a> ()</td></tr>
<tr class="memdesc:ada0ecf739088a765ebc7fbc4181bb375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to an <a class="el" href="class_e_m_a_c_interface.html" title="EMACInterface class Implementation of the NetworkInterface for an EMAC-based driver.">EMACInterface</a>.  <br /></td></tr>
<tr class="separator:ada0ecf739088a765ebc7fbc4181bb375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55ca6584533439ab78cfd487a2c56f" id="r_aed55ca6584533439ab78cfd487a2c56f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_cellular_interface.html">CellularInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#aed55ca6584533439ab78cfd487a2c56f">cellularInterface</a> ()</td></tr>
<tr class="memdesc:aed55ca6584533439ab78cfd487a2c56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_cellular_interface.html" title="Common interface that is shared between cellular interfaces.">CellularInterface</a>.  <br /></td></tr>
<tr class="separator:aed55ca6584533439ab78cfd487a2c56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6341e2fee78baf07a8211dd9d323829c" id="r_a6341e2fee78baf07a8211dd9d323829c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_wi_fi_interface.html">WiFiInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wi_fi_interface.html#a6341e2fee78baf07a8211dd9d323829c">get_default_instance</a> ()</td></tr>
<tr class="memdesc:a6341e2fee78baf07a8211dd9d323829c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default Wi-Fi interface.  <br /></td></tr>
<tr class="separator:a6341e2fee78baf07a8211dd9d323829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6a40480984abd3587ff923a104493371" id="r_a6a40480984abd3587ff923a104493371"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_stack.html#a6a40480984abd3587ff923a104493371">socket_open</a> (void **handle, nsapi_protocol_t proto) override</td></tr>
<tr class="memdesc:a6a40480984abd3587ff923a104493371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a socket.  <br /></td></tr>
<tr class="separator:a6a40480984abd3587ff923a104493371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d4745b7121f7b830580f3d74697932" id="r_aa6d4745b7121f7b830580f3d74697932"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_stack.html#aa6d4745b7121f7b830580f3d74697932">socket_close</a> (void *handle) override</td></tr>
<tr class="memdesc:aa6d4745b7121f7b830580f3d74697932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <br /></td></tr>
<tr class="separator:aa6d4745b7121f7b830580f3d74697932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bde2c3867a72bbcb3de0c745408b73" id="r_a15bde2c3867a72bbcb3de0c745408b73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_stack.html#a15bde2c3867a72bbcb3de0c745408b73">socket_bind</a> (void *handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address) override</td></tr>
<tr class="memdesc:a15bde2c3867a72bbcb3de0c745408b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a specific address to a socket.  <br /></td></tr>
<tr class="separator:a15bde2c3867a72bbcb3de0c745408b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af433c545c5dec34e4454f33a047275e7" id="r_af433c545c5dec34e4454f33a047275e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_stack.html#af433c545c5dec34e4454f33a047275e7">socket_listen</a> (void *handle, int backlog) override</td></tr>
<tr class="memdesc:af433c545c5dec34e4454f33a047275e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for connections on a TCP socket.  <br /></td></tr>
<tr class="separator:af433c545c5dec34e4454f33a047275e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d1860b270587f5aa45ee52f99794f5" id="r_af6d1860b270587f5aa45ee52f99794f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_stack.html#af6d1860b270587f5aa45ee52f99794f5">socket_connect</a> (void *handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address) override</td></tr>
<tr class="memdesc:af6d1860b270587f5aa45ee52f99794f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects TCP socket to a remote host.  <br /></td></tr>
<tr class="separator:af6d1860b270587f5aa45ee52f99794f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad27bf9c30dcc520ddde0cf3d8e39434" id="r_aad27bf9c30dcc520ddde0cf3d8e39434"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_stack.html#aad27bf9c30dcc520ddde0cf3d8e39434">socket_accept</a> (void *handle, void **socket, <a class="el" href="class_socket_address.html">SocketAddress</a> *address) override</td></tr>
<tr class="memdesc:aad27bf9c30dcc520ddde0cf3d8e39434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a connection on a TCP socket.  <br /></td></tr>
<tr class="separator:aad27bf9c30dcc520ddde0cf3d8e39434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b5c1fd2bc705be0cc7651532008b8a" id="r_a70b5c1fd2bc705be0cc7651532008b8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a70b5c1fd2bc705be0cc7651532008b8a">socket_send</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, const void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size)=0</td></tr>
<tr class="memdesc:a70b5c1fd2bc705be0cc7651532008b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data over a TCP socket.  <br /></td></tr>
<tr class="separator:a70b5c1fd2bc705be0cc7651532008b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178a8c725d8f646ff6b26b381d2ac2c6" id="r_a178a8c725d8f646ff6b26b381d2ac2c6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a178a8c725d8f646ff6b26b381d2ac2c6">socket_recv</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size)=0</td></tr>
<tr class="memdesc:a178a8c725d8f646ff6b26b381d2ac2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data over a TCP socket.  <br /></td></tr>
<tr class="separator:a178a8c725d8f646ff6b26b381d2ac2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c6134df4d9116db6d9354c000bc354" id="r_a75c6134df4d9116db6d9354c000bc354"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a75c6134df4d9116db6d9354c000bc354">socket_sendto</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size)=0</td></tr>
<tr class="memdesc:a75c6134df4d9116db6d9354c000bc354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet over a UDP socket.  <br /></td></tr>
<tr class="separator:a75c6134df4d9116db6d9354c000bc354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33819f2c330cad315163b285e28371e0" id="r_a33819f2c330cad315163b285e28371e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a33819f2c330cad315163b285e28371e0">socket_recvfrom</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, void *buffer, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size)=0</td></tr>
<tr class="memdesc:a33819f2c330cad315163b285e28371e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a packet over a UDP socket.  <br /></td></tr>
<tr class="separator:a33819f2c330cad315163b285e28371e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39dc687ca69ce33807642fee47e7db8" id="r_aa39dc687ca69ce33807642fee47e7db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_stack.html#aa39dc687ca69ce33807642fee47e7db8">socket_attach</a> (void *handle, void(*callback)(void *), void *data) override</td></tr>
<tr class="memdesc:aa39dc687ca69ce33807642fee47e7db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback on state change of the socket.  <br /></td></tr>
<tr class="separator:aa39dc687ca69ce33807642fee47e7db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8429ad8879c1d08d54b63fc924ef813" id="r_ac8429ad8879c1d08d54b63fc924ef813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_stack.html#ac8429ad8879c1d08d54b63fc924ef813">setsockopt</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, int level, int optname, const void *optval, unsigned optlen) override</td></tr>
<tr class="memdesc:ac8429ad8879c1d08d54b63fc924ef813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stack-specific socket options.  <br /></td></tr>
<tr class="separator:ac8429ad8879c1d08d54b63fc924ef813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04dfecc2e0bfbabacd39ed4887c8f1a" id="r_ad04dfecc2e0bfbabacd39ed4887c8f1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_s_p32_stack.html#ad04dfecc2e0bfbabacd39ed4887c8f1a">getsockopt</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, int level, int optname, void *optval, unsigned *optlen) override</td></tr>
<tr class="memdesc:ad04dfecc2e0bfbabacd39ed4887c8f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stack-specific socket options.  <br /></td></tr>
<tr class="separator:ad04dfecc2e0bfbabacd39ed4887c8f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e5ab3271a4df6347b400bd7e16fdc0" id="r_aa6e5ab3271a4df6347b400bd7e16fdc0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aa6e5ab3271a4df6347b400bd7e16fdc0">socket_sendto_control</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size, <a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *control, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> control_size)</td></tr>
<tr class="memdesc:aa6e5ab3271a4df6347b400bd7e16fdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet with ancillary data over a UDP socket.  <br /></td></tr>
<tr class="separator:aa6e5ab3271a4df6347b400bd7e16fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345f6e49fcae39c08ca892e2d1b6337b" id="r_a345f6e49fcae39c08ca892e2d1b6337b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a345f6e49fcae39c08ca892e2d1b6337b">socket_recvfrom_control</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size, <a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *control, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> control_size)</td></tr>
<tr class="memdesc:a345f6e49fcae39c08ca892e2d1b6337b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a packet with ancillary data over a UDP socket.  <br /></td></tr>
<tr class="separator:a345f6e49fcae39c08ca892e2d1b6337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> class Implementation of the <a class="el" href="class_network_stack.html" title="NetworkStack class.">NetworkStack</a> for the ESP32. </p>

<p class="definition">Definition at line <a class="el" href="_e_s_p32_interface_8h_source.html#l00025">25</a> of file <a class="el" href="_e_s_p32_interface_8h_source.html">ESP32Interface.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7640d35fa5798e1ff5ce0cf9a7faa097" name="a7640d35fa5798e1ff5ce0cf9a7faa097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7640d35fa5798e1ff5ce0cf9a7faa097">&#9670;&#160;</a></span>call_in_callback_cb_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;<a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> (int delay_ms, <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;void()&gt; user_cb)&gt; <a class="el" href="class_network_stack.html#a7640d35fa5798e1ff5ce0cf9a7faa097">call_in_callback_cb_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type for a call-in callback. </p>
<p>This is a pointer to a function that will call the provided callback from the network stack after a given delay, or immediately if <code>delay_ms</code> is 0. </p>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00235">235</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<a id="abb962f363d7a7ec29b27844a1e5f7ecc" name="abb962f363d7a7ec29b27844a1e5f7ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb962f363d7a7ec29b27844a1e5f7ecc">&#9670;&#160;</a></span>hostbyname_cb_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;void (<a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> result, <a class="el" href="class_socket_address.html">SocketAddress</a> *address)&gt; <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hostname translation callback (for use with <a class="el" href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7" title="Translate a hostname to an IP address (asynchronous) using network interface name.">gethostbyname_async()</a>). </p>
<p>Callback will be called after <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution completes or a failure occurs.</p>
<dl class="section note"><dt>Note</dt><dd>Callback should not take more than 10ms to execute, otherwise it might prevent underlying thread processing. A portable user of the callback should not make calls to network operations due to stack size limitations. The callback should not perform expensive operations such as socket recv/send calls or blocking operations.</dd></dl>
<p><br  />
 <code>result</code> : Negative error code on failure, or value that represents the number of <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> records <br  />
 <code>address</code> : On success, destination for the host <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a>. </p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00303">303</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a53e7a6b756107d4ab01a7efbfabb74d3" name="a53e7a6b756107d4ab01a7efbfabb74d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e7a6b756107d4ab01a7efbfabb74d3">&#9670;&#160;</a></span>ESP32Interface() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_s_p32_interface.html">ESP32Interface</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> lifetime Configuration defined in mbed_lib.json. </p>

</div>
</div>
<a id="a8f422971062c7154ef1b61b6388f6765" name="a8f422971062c7154ef1b61b6388f6765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f422971062c7154ef1b61b6388f6765">&#9670;&#160;</a></span>ESP32Interface() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_s_p32_interface.html">ESP32Interface</a> </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>en</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>io0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>rts</em> = <code>NC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>cts</em> = <code>NC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baudrate</em> = <code>230400</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> lifetime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">en</td><td>EN pin (If not used this pin, please set "NC") </td></tr>
    <tr><td class="paramname">io0</td><td>IO0 pin (If not used this pin, please set "NC") </td></tr>
    <tr><td class="paramname">tx</td><td>TX pin </td></tr>
    <tr><td class="paramname">rx</td><td>RX pin </td></tr>
    <tr><td class="paramname">debug</td><td>Enable debugging </td></tr>
    <tr><td class="paramname">rts</td><td>RTS pin </td></tr>
    <tr><td class="paramname">cts</td><td>CTS pin </td></tr>
    <tr><td class="paramname">baudrate</td><td>The baudrate of the serial port (default = 230400). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94acf89498ebbfdc57eaa3d8435fdaa6" name="a94acf89498ebbfdc57eaa3d8435fdaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94acf89498ebbfdc57eaa3d8435fdaa6">&#9670;&#160;</a></span>~ESP32Interface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_e_s_p32_interface.html">ESP32Interface</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> default destructor. </p>

</div>
</div>
<a id="a9b789bec3883332ef9d49b07f2f7c61d" name="a9b789bec3883332ef9d49b07f2f7c61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b789bec3883332ef9d49b07f2f7c61d">&#9670;&#160;</a></span>ESP32Interface() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_s_p32_interface.html">ESP32Interface</a> </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_e_s_p32_interface.html" title="ESP32Interface class Implementation of the NetworkStack for the ESP32.">ESP32Interface</a> lifetime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>TX pin </td></tr>
    <tr><td class="paramname">rx</td><td>RX pin </td></tr>
    <tr><td class="paramname">debug</td><td>Enable debugging </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9919ef603c0c526ec73722610bd877ca" name="a9919ef603c0c526ec73722610bd877ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9919ef603c0c526ec73722610bd877ca">&#9670;&#160;</a></span>set_network()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_network </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>ip_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>netmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>gateway</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure this network interface to use a static IP address. </p>
<p>Implicitly disables DHCP, which can be enabled in set_dhcp. Requires that the network is disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> object containing the local IP address </td></tr>
    <tr><td class="paramname">netmask</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> object containing the local network mask </td></tr>
    <tr><td class="paramname">gateway</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> object containing the local gateway </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this function is unsupported </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#afaa2847bf9555fb3b9915b31ec906dc7">NetworkInterface</a>.</p>

</div>
</div>
<a id="a8e39d3de385c6227267f23666ea86eb3" name="a8e39d3de385c6227267f23666ea86eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e39d3de385c6227267f23666ea86eb3">&#9670;&#160;</a></span>set_dhcp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_dhcp </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dhcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable DHCP on connecting the network. </p>
<p>Enabled by default unless a static IP address has been assigned. Requires that the network is disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dhcp</td><td>True to enable DHCP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success. </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if operation is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a29e2da4ebf1e48a023e9306d66332e8d">NetworkInterface</a>.</p>

</div>
</div>
<a id="a8e3eb3944219908ecdae29dfaea47656" name="a8e3eb3944219908ecdae29dfaea47656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3eb3944219908ecdae29dfaea47656">&#9670;&#160;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to connect to a Wi-Fi network. </p>
<p>Requires ssid and passphrase to be set. If passphrase is invalid, NSAPI_ERROR_AUTH_ERROR is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_wi_fi_interface.html#a4a3e9612acae25a6a96fb916b5cf858b">WiFiInterface</a>.</p>

</div>
</div>
<a id="a6abe553131db3322747534c21ef921aa" name="a6abe553131db3322747534c21ef921aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abe553131db3322747534c21ef921aa">&#9670;&#160;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ssid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#ga022366557c25927ba58a66197c1e813b">nsapi_security_t</a>&#160;</td>
          <td class="paramname"><em>security</em> = <code><a class="el" href="group___net_socket.html#gga0bfcdf6a9abae30715b5e7f43ae4a0c5a54dc678bd03b26b31588ca37aee6c713">NSAPI_SECURITY_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to connect to a Wi-Fi network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssid</td><td>Name of the network to connect to. </td></tr>
    <tr><td class="paramname">pass</td><td>Security passphrase to connect to the network. </td></tr>
    <tr><td class="paramname">security</td><td>Type of encryption for connection (Default: NSAPI_SECURITY_NONE). </td></tr>
    <tr><td class="paramname">channel</td><td>Channel to make the connection, or 0 for any (Default: 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, or error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_wi_fi_interface.html#a2a0180b5ee1c2f2706fa5a591cf71f51">WiFiInterface</a>.</p>

</div>
</div>
<a id="a673ad5763bd4caf275960bfcd2f44419" name="a673ad5763bd4caf275960bfcd2f44419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673ad5763bd4caf275960bfcd2f44419">&#9670;&#160;</a></span>set_credentials()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int set_credentials </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ssid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#ga022366557c25927ba58a66197c1e813b">nsapi_security_t</a>&#160;</td>
          <td class="paramname"><em>security</em> = <code><a class="el" href="group___net_socket.html#gga0bfcdf6a9abae30715b5e7f43ae4a0c5a54dc678bd03b26b31588ca37aee6c713">NSAPI_SECURITY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Wi-Fi network credentials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssid</td><td>Name of the network to connect to. </td></tr>
    <tr><td class="paramname">pass</td><td>Security passphrase to connect to the network. </td></tr>
    <tr><td class="paramname">security</td><td>Type of encryption for connection (defaults to NSAPI_SECURITY_NONE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, or error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_wi_fi_interface.html#a8c2bab218314212a4e19130a939958e2">WiFiInterface</a>.</p>

</div>
</div>
<a id="afbc78fca8fe9cf20f5ed56aefe983613" name="afbc78fca8fe9cf20f5ed56aefe983613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc78fca8fe9cf20f5ed56aefe983613">&#9670;&#160;</a></span>set_channel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int set_channel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Wi-Fi network channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel to make the connection, or 0 for any (Default: 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, or error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_wi_fi_interface.html#a19fbf6093cda714d1edd10d70d0c20a6">WiFiInterface</a>.</p>

</div>
</div>
<a id="acd5b7c7b173b315e777e384245ca2a13" name="acd5b7c7b173b315e777e384245ca2a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5b7c7b173b315e777e384245ca2a13">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the interface. </p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, or error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_wi_fi_interface.html#a8f6d6477ccb0877df3e58628f4ccbf52">WiFiInterface</a>.</p>

</div>
</div>
<a id="a3d1b72fe745784e4f851ce9c59fb4536" name="a3d1b72fe745784e4f851ce9c59fb4536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1b72fe745784e4f851ce9c59fb4536">&#9670;&#160;</a></span>get_ip_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ip_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local IP address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the local IP address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#a2ab48210e24fc7efb4e1cada14c4b57b">NetworkStack</a>.</p>

</div>
</div>
<a id="a1d3eff5846155587cbfbc854c1203d16" name="a1d3eff5846155587cbfbc854c1203d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3eff5846155587cbfbc854c1203d16">&#9670;&#160;</a></span>get_mac_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * get_mac_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local MAC address. </p>
<p>Provided MAC address is intended for info or debug purposes and may be not provided if the underlying network interface does not provide a MAC address.</p>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated representation of the local MAC address or null if no MAC address is available. </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#aaf0ca1fccad1a27c1e76403676192347">NetworkInterface</a>.</p>

</div>
</div>
<a id="a4daefe15c491142d649cc33382372c68" name="a4daefe15c491142d649cc33382372c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4daefe15c491142d649cc33382372c68">&#9670;&#160;</a></span>get_gateway()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_gateway </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local gateway. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of gateway address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#ae69c5f0f38bd060ad04d10bc1277ae0e">NetworkInterface</a>.</p>

</div>
</div>
<a id="a67ba6febc74251569b88acfabaa08948" name="a67ba6febc74251569b88acfabaa08948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ba6febc74251569b88acfabaa08948">&#9670;&#160;</a></span>get_netmask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_netmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local network mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of netmask </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a3709144cc9b275c18abe2a414872f140">NetworkInterface</a>.</p>

</div>
</div>
<a id="a856cd17a1511857c58afdeb59b16591b" name="a856cd17a1511857c58afdeb59b16591b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856cd17a1511857c58afdeb59b16591b">&#9670;&#160;</a></span>get_rssi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int8_t get_rssi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current radio signal strength for active connection. </p>
<dl class="section return"><dt>Returns</dt><dd>Connection strength in dBm (negative value), or 0 if measurement impossible. </dd></dl>

<p>Implements <a class="el" href="class_wi_fi_interface.html#a6a0aa49107e0c11078578fa47ba6999c">WiFiInterface</a>.</p>

</div>
</div>
<a id="a91f2033b4f0a88ffc36eb43c11f3dba6" name="a91f2033b4f0a88ffc36eb43c11f3dba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f2033b4f0a88ffc36eb43c11f3dba6">&#9670;&#160;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt;&#160;</td>
          <td class="paramname"><em>status_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register callback for status reporting. </p>
<p>The specified status callback function will be called on status changes on the network. The parameters on the callback are the event type and event-type dependent reason parameter. Only one callback can be registered at a time.</p>
<p>To unregister a callback call with status_cb parameter as a zero.</p>
<p><em>NOTE:</em> Any callbacks registered with this function will be overwritten if <a class="el" href="class_network_interface.html#ab61fc4dcb3f255e327c189325eee1e43" title="Add event listener for interface.">add_event_listener()</a> API is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_cb</td><td>The callback for status changes. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a27082cfcaab9462699208893d05a70d1">NetworkInterface</a>.</p>

</div>
</div>
<a id="a2ba659ec308e54e6b45efb55b4195e95" name="a2ba659ec308e54e6b45efb55b4195e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba659ec308e54e6b45efb55b4195e95">&#9670;&#160;</a></span>get_connection_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nsapi_connection_status_t get_connection_status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the connection status. </p>
<dl class="section return"><dt>Returns</dt><dd>The connection status (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nsapi__types_8h_source.html">nsapi_types.h</a>). </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a840e46edfb6792d1c588cf95c0387cd6">NetworkInterface</a>.</p>

</div>
</div>
<a id="a5eeb3e01ec53546b61fd7b823a4980ef" name="a5eeb3e01ec53546b61fd7b823a4980ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eeb3e01ec53546b61fd7b823a4980ef">&#9670;&#160;</a></span>gethostbyname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to an IP address with specific version using network interface name. </p>
<p>The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">address</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> to store the result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">int</td><td>Negative error code on failure. See <a class="el" href="class_network_stack.html#a5eeb3e01ec53546b61fd7b823a4980ef">NetworkStack::gethostbyname</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#a5eeb3e01ec53546b61fd7b823a4980ef">NetworkStack</a>.</p>

</div>
</div>
<a id="a260338652be8fba7b1004bc924fdb781" name="a260338652be8fba7b1004bc924fdb781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260338652be8fba7b1004bc924fdb781">&#9670;&#160;</a></span>add_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> add_dns_server </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a domain name server to list of servers to query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address for the dns host. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name. Currently unused, the server is added for all interfaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#adbf8dbcd865fee3ebef07fefbea802a7">NetworkStack</a>.</p>

</div>
</div>
<a id="a6a40480984abd3587ff923a104493371" name="a6a40480984abd3587ff923a104493371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a40480984abd3587ff923a104493371">&#9670;&#160;</a></span>socket_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_open </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_protocol_t&#160;</td>
          <td class="paramname"><em>proto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a socket. </p>
<p>Creates a network socket and stores it in the specified handle. The handle must be passed to following calls on the socket.</p>
<p>A stack may have a finite number of sockets, in this case NSAPI_ERROR_NO_SOCKET is returned if no socket is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Destination for the handle to a newly created socket </td></tr>
    <tr><td class="paramname">proto</td><td>Protocol of socket to open, NSAPI_TCP or NSAPI_UDP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a917003ace34919b35f8e1dced0b52a05">NetworkStack</a>.</p>

</div>
</div>
<a id="aa6d4745b7121f7b830580f3d74697932" name="aa6d4745b7121f7b830580f3d74697932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d4745b7121f7b830580f3d74697932">&#9670;&#160;</a></span>socket_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p>Closes any open connection and deallocates any memory associated with the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a519c5ecb722a17ea2acafad17f9386a3">NetworkStack</a>.</p>

</div>
</div>
<a id="a15bde2c3867a72bbcb3de0c745408b73" name="a15bde2c3867a72bbcb3de0c745408b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bde2c3867a72bbcb3de0c745408b73">&#9670;&#160;</a></span>socket_bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_bind </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a specific address to a socket. </p>
<p>Binding a socket specifies the address and port on which to receive data. If the IP address is zeroed, only the port is bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>Local address to bind </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#ac92c15ee2f3ef7e26cb881393559d1ff">NetworkStack</a>.</p>

</div>
</div>
<a id="af433c545c5dec34e4454f33a047275e7" name="af433c545c5dec34e4454f33a047275e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af433c545c5dec34e4454f33a047275e7">&#9670;&#160;</a></span>socket_listen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_listen </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Listen for connections on a TCP socket. </p>
<p>Marks the socket as a passive socket that can be used to accept incoming connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">backlog</td><td>Number of pending connections that can be queued simultaneously </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a45a50de4d7a421ac592f7effa7765639">NetworkStack</a>.</p>

</div>
</div>
<a id="af6d1860b270587f5aa45ee52f99794f5" name="af6d1860b270587f5aa45ee52f99794f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d1860b270587f5aa45ee52f99794f5">&#9670;&#160;</a></span>socket_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_connect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects TCP socket to a remote host. </p>
<p>Initiates a connection to a remote server specified by the indicated address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> of the remote host </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#ad584c350cb47627892fd2783e4c0c88a">NetworkStack</a>.</p>

</div>
</div>
<a id="aad27bf9c30dcc520ddde0cf3d8e39434" name="aad27bf9c30dcc520ddde0cf3d8e39434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad27bf9c30dcc520ddde0cf3d8e39434">&#9670;&#160;</a></span>socket_accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_accept </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts a connection on a TCP socket. </p>
<p>The server socket must be bound and set to listen for connections. On a new connection, creates a network socket and stores it in the specified handle. The handle must be passed to following calls on the socket.</p>
<p>A stack may have a finite number of sockets, in this case NSAPI_ERROR_NO_SOCKET is returned if no socket is available.</p>
<p>This call is non-blocking. If accept would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">server</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle to server to accept from </td></tr>
    <tr><td class="paramname">handle</td><td>Destination for a handle to the newly created socket </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the remote address or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#aa497dbf81d1e9844f7c73ea44a9b6e54">NetworkStack</a>.</p>

</div>
</div>
<a id="a70b5c1fd2bc705be0cc7651532008b8a" name="a70b5c1fd2bc705be0cc7651532008b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b5c1fd2bc705be0cc7651532008b8a">&#9670;&#160;</a></span>socket_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send data over a TCP socket. </p>
<p>The socket must be connected to a remote host. Returns the number of bytes sent from the buffer.</p>
<p>This call is non-blocking. If send would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">data</td><td>Buffer of data to send to the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sent bytes on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#af715b34a97a4bfb91b3694d308cdfd71">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#a9e66843535784598a3fa76105801e77f">Nanostack</a>.</p>

</div>
</div>
<a id="a178a8c725d8f646ff6b26b381d2ac2c6" name="a178a8c725d8f646ff6b26b381d2ac2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178a8c725d8f646ff6b26b381d2ac2c6">&#9670;&#160;</a></span>socket_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data over a TCP socket. </p>
<p>The socket must be connected to a remote host. Returns the number of bytes received into the buffer.</p>
<p>This call is non-blocking. If recv would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">data</td><td>Destination buffer for data received from the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#abadfc103bba741fc2a9b403aa9f58985">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#aed43f4c030344db652e7821fd0fff994">Nanostack</a>.</p>

</div>
</div>
<a id="a75c6134df4d9116db6d9354c000bc354" name="a75c6134df4d9116db6d9354c000bc354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c6134df4d9116db6d9354c000bc354">&#9670;&#160;</a></span>socket_sendto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_sendto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a packet over a UDP socket. </p>
<p>Sends data to the specified address. Returns the number of bytes sent from the buffer.</p>
<p>This call is non-blocking. If sendto would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> of the remote host </td></tr>
    <tr><td class="paramname">data</td><td>Buffer of data to send to the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sent bytes on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a6b32b9bfc80dcd9a9108b5913ba0ac3a">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#aceb411cbca87cde852280cb94a982f73">Nanostack</a>.</p>

</div>
</div>
<a id="a33819f2c330cad315163b285e28371e0" name="a33819f2c330cad315163b285e28371e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33819f2c330cad315163b285e28371e0">&#9670;&#160;</a></span>socket_recvfrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_recvfrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a packet over a UDP socket. </p>
<p>Receives data and stores the source address in address if address is not NULL. Returns the number of bytes received into the buffer.</p>
<p>This call is non-blocking. If recvfrom would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the source address or NULL </td></tr>
    <tr><td class="paramname">buffer</td><td>Destination buffer for data received from the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a83fe036e785a5410bd4ed24b9c7a2399">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#a264b90bbb8fd5b6a5ac0c93ea5617453">Nanostack</a>.</p>

</div>
</div>
<a id="aa39dc687ca69ce33807642fee47e7db8" name="aa39dc687ca69ce33807642fee47e7db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39dc687ca69ce33807642fee47e7db8">&#9670;&#160;</a></span>socket_attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void socket_attach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a callback on state change of the socket. </p>
<p>The specified callback will be called on state changes such as when the socket can recv/send/accept successfully and on when an error occurs. The callback may also be called spuriously without reason.</p>
<p>The callback may be called in an interrupt context and should not perform expensive operations such as recv/send calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call on state change </td></tr>
    <tr><td class="paramname">data</td><td>Argument to pass to callback </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_network_stack.html#a836e3ddbc6fea2ce55bfcb477f56387c">NetworkStack</a>.</p>

</div>
</div>
<a id="ac8429ad8879c1d08d54b63fc924ef813" name="ac8429ad8879c1d08d54b63fc924ef813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8429ad8879c1d08d54b63fc924ef813">&#9670;&#160;</a></span>setsockopt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> setsockopt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set stack-specific socket options. </p>
<p>The setsockopt allow an application to pass stack-specific hints to the underlying stack. For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned and the socket is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle. </td></tr>
    <tr><td class="paramname">level</td><td>Stack-specific protocol level. </td></tr>
    <tr><td class="paramname">optname</td><td>Stack-specific option identifier. </td></tr>
    <tr><td class="paramname">optval</td><td>Option value. </td></tr>
    <tr><td class="paramname">optlen</td><td>Length of the option value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#aac9e14a8be89337c5aea17fd705c3f46">NetworkStack</a>.</p>

</div>
</div>
<a id="ad04dfecc2e0bfbabacd39ed4887c8f1a" name="ad04dfecc2e0bfbabacd39ed4887c8f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04dfecc2e0bfbabacd39ed4887c8f1a">&#9670;&#160;</a></span>getsockopt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> getsockopt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get stack-specific socket options. </p>
<p>The getstackopt allow an application to retrieve stack-specific hints from the underlying stack. For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned and optval is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle. </td></tr>
    <tr><td class="paramname">level</td><td>Stack-specific protocol level. </td></tr>
    <tr><td class="paramname">optname</td><td>Stack-specific option identifier. </td></tr>
    <tr><td class="paramname">optval</td><td>Destination for option value. </td></tr>
    <tr><td class="paramname">optlen</td><td>Length of the option value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#add47ee70f334bcabd0df63f116143311">NetworkStack</a>.</p>

</div>
</div>
<a id="a77de8d1afa4b83dd6f560dc39251e1eb" name="a77de8d1afa4b83dd6f560dc39251e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77de8d1afa4b83dd6f560dc39251e1eb">&#9670;&#160;</a></span>get_ipv6_link_local_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ipv6_link_local_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the IPv6 link local address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the link local IPv6 address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad597f0496e42b17be72d00fa832e0963" name="ad597f0496e42b17be72d00fa832e0963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad597f0496e42b17be72d00fa832e0963">&#9670;&#160;</a></span>get_ip_address_if()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ip_address_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local IP address on interface name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the link local IPv6 address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87a975b9ef736cef63334895c5770660" name="a87a975b9ef736cef63334895c5770660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a975b9ef736cef63334895c5770660">&#9670;&#160;</a></span>getaddrinfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to the multiple IP addresses with specific version using network interface name. </p>
<p>The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> array to store the result.. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of results on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a4e2299044fa2bbb37717a7661bb608f7">DNS</a>.</p>

</div>
</div>
<a id="ab43b64cae1f145615db7f697d34552d7" name="ab43b64cae1f145615db7f697d34552d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43b64cae1f145615db7f697d34552d7">&#9670;&#160;</a></span>gethostbyname_async() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> gethostbyname_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a hostname to multiple IP addresses (asynchronous) </p>
<p>The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p>Call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC) </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#aede5e7d96c7b2141f60a9fefec11e462">DNS</a>.</p>

<p>Reimplemented in <a class="el" href="class_nanostack.html#a7d8f4d21e64602c2c035da0ed5b1e9d9">Nanostack</a>.</p>

</div>
</div>
<a id="aa964732e6c585b596adc760fe95f40f5" name="aa964732e6c585b596adc760fe95f40f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa964732e6c585b596adc760fe95f40f5">&#9670;&#160;</a></span>getaddrinfo_async() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a hostname to the multiple IP addresses (asynchronous) </p>
<p>The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p>The call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case that IP addresses are found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache, callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#afd29392442faa47f202cd69ede31dd03">DNS</a>.</p>

</div>
</div>
<a id="a26000e958701f5b35886fac1757c0bf4" name="a26000e958701f5b35886fac1757c0bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26000e958701f5b35886fac1757c0bf4">&#9670;&#160;</a></span>gethostbyname_async_cancel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname_async_cancel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels asynchronous hostname translation. </p>
<p>When translation is cancelled, callback will not be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique id of the hostname translation operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a3ba06c19476ec03988c7cd7807823d63">DNS</a>.</p>

</div>
</div>
<a id="a0ccb0f7a5af95e76d0dea335ab866047" name="a0ccb0f7a5af95e76d0dea335ab866047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccb0f7a5af95e76d0dea335ab866047">&#9670;&#160;</a></span>get_dns_server() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_dns_server </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a domain name server from a list of servers to query. </p>
<p>Returns a <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server address for a index. If returns error no more <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> servers to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server, starts from zero </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the host address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Reimplemented in <a class="el" href="class_nanostack.html#ac364a724950ce42c37299985a1c01cda">Nanostack</a>.</p>

</div>
</div>
<a id="aa5f46dd32614b93bc8a9d41b822a7ab7" name="aa5f46dd32614b93bc8a9d41b822a7ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f46dd32614b93bc8a9d41b822a7ab7">&#9670;&#160;</a></span>onboardNetworkStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_onboard_network_stack.html">OnboardNetworkStack</a> * onboardNetworkStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic downcast to a <a class="el" href="class_onboard_network_stack.html" title="mbed OS API for onboard IP stack abstraction">OnboardNetworkStack</a>. </p>

<p>Reimplemented in <a class="el" href="class_onboard_network_stack.html#a320ba06d48aa2401a4e62d69b79297ba">OnboardNetworkStack</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00225">225</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<a id="aa6e5ab3271a4df6347b400bd7e16fdc0" name="aa6e5ab3271a4df6347b400bd7e16fdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e5ab3271a4df6347b400bd7e16fdc0">&#9670;&#160;</a></span>socket_sendto_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_sendto_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>control_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a packet with ancillary data over a UDP socket. </p>
<p>Sends data to the specified address. Returns the number of bytes sent from the buffer.</p>
<p>This call is non-blocking. If sendto would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> of the remote host </td></tr>
    <tr><td class="paramname">data</td><td>Buffer of data to send to the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
    <tr><td class="paramname">control</td><td>Storage for ancillary data </td></tr>
    <tr><td class="paramname">control_size</td><td>Size of ancillary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sent bytes on success, negative error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00408">408</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<a id="a345f6e49fcae39c08ca892e2d1b6337b" name="a345f6e49fcae39c08ca892e2d1b6337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345f6e49fcae39c08ca892e2d1b6337b">&#9670;&#160;</a></span>socket_recvfrom_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_recvfrom_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>control_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a packet with ancillary data over a UDP socket. </p>
<p>Receives data and stores the source address in address if address is not NULL. Returns the number of bytes received into the buffer.</p>
<p>Ancillary data is stored into <code>control</code>. The caller needs to allocate a buffer that is large enough to contain the data they want to receive, then pass the pointer in through the <code>control</code> member. The data will be filled into <code>control</code>, beginning with a header specifying what data was received. See <a class="el" href="struct_msg_header_iterator.html" title="Allows iteration through the list of message headers received in the control parameter of the socket_...">MsgHeaderIterator</a> for how to parse this data.</p>
<p>This call is non-blocking. If recvfrom would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the source address or NULL </td></tr>
    <tr><td class="paramname">data</td><td>Destination buffer for data received from the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
    <tr><td class="paramname">control</td><td>Storage for ancillary data </td></tr>
    <tr><td class="paramname">control_size</td><td>Size of ancillary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes on success, negative error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00441">441</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<a id="a6341e2fee78baf07a8211dd9d323829c" name="a6341e2fee78baf07a8211dd9d323829c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6341e2fee78baf07a8211dd9d323829c">&#9670;&#160;</a></span>get_default_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_wi_fi_interface.html">WiFiInterface</a> * get_default_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default Wi-Fi interface. </p>
<p>This is provided as a weak method so applications can override it. Default behavior is to get the target's default interface, if any.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to interface, if any. </dd></dl>

</div>
</div>
<a id="afc8fee7fdad17ce5709afd57cf51743a" name="afc8fee7fdad17ce5709afd57cf51743a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8fee7fdad17ce5709afd57cf51743a">&#9670;&#160;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wi_fi_access_point.html">WiFiAccessPoint</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan for available networks. </p>
<dl class="section note"><dt>Note</dt><dd>This is a blocking function.</dd></dl>
<p>If the <code>count</code> is 0, the function only returns the number of available networks. If the <code>count</code> is greater than 0 and the <code>res</code> is not NULL, the array of discovered APs is populated with discovered networks up to the value of the <code>count</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>Pointer to allocated array to store discovered APs. </td></tr>
    <tr><td class="paramname">count</td><td>Size of allocated res array, or 0 to only count available APs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of entries in res, or if count was 0, number of available networks. Negative on error (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nsapi__types_8h_source.html">nsapi_types.h</a> for <a class="el" href="group___net_socket.html#gac21eb8156cf9af198349069cdc7afeba" title="Enum of standardized error codes.">nsapi_error</a>). </dd></dl>

</div>
</div>
<a id="ac47da289e164960eaeea7f2a4d155003" name="ac47da289e164960eaeea7f2a4d155003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47da289e164960eaeea7f2a4d155003">&#9670;&#160;</a></span>wifiInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wi_fi_interface.html">WiFiInterface</a> * wifiInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_wi_fi_interface.html" title="Common interface between Wi-Fi devices.">WiFiInterface</a>.   </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface.   </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a09d99efafd15a9d84a77761372e838d5">NetworkInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_wi_fi_interface_8h_source.html#l00110">110</a> of file <a class="el" href="_wi_fi_interface_8h_source.html">WiFiInterface.h</a>.</p>

</div>
</div>
<a id="a68e37f9f2a19ab17cc5c7baebf6293de" name="a68e37f9f2a19ab17cc5c7baebf6293de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e37f9f2a19ab17cc5c7baebf6293de">&#9670;&#160;</a></span>set_default_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_default_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>defined(DOXYGEN_ONLY) </p>
<p>Set default parameters on a Wi-Fi interface.</p>
<p>A Wi-Fi interface instantiated directly or using <a class="el" href="class_wi_fi_interface.html#a6341e2fee78baf07a8211dd9d323829c" title="Get the default Wi-Fi interface.">WiFiInterface::get_default_instance()</a> is initially unconfigured. This call can be used to set the default parameters that would have been set if the interface had been requested using <a class="el" href="class_network_interface.html#a00c2abaa91df1131639e63d980866244" title="Return the default network interface.">NetworkInterface::get_default_instance()</a> (see nsapi JSON configuration). </p>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a123d2c4ef90c33aec33471ac040049c1">NetworkInterface</a>.</p>

</div>
</div>
<a id="a4a94b10f0ae842556ebb0e0775b557cb" name="a4a94b10f0ae842556ebb0e0775b557cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a94b10f0ae842556ebb0e0775b557cb">&#9670;&#160;</a></span>set_as_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_as_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set network interface as default one. </p>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a344c00309ca7046be3644d12458d0e59">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#a344c00309ca7046be3644d12458d0e59">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#a344c00309ca7046be3644d12458d0e59">PPPInterface</a>.</p>

</div>
</div>
<a id="a42ea7f00483d172baf3a98f3ca2bab2a" name="a42ea7f00483d172baf3a98f3ca2bab2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ea7f00483d172baf3a98f3ca2bab2a">&#9670;&#160;</a></span>get_hostname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * get_hostname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get hostname. </p>
<dl class="section return"><dt>Returns</dt><dd>Hostname if configured, null otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a6c8a27f5d4c87d6a7a9ea1018fa26188">EMACInterface</a>.</p>

</div>
</div>
<a id="a26c52a8dbbacfc52ee1a255c156ed569" name="a26c52a8dbbacfc52ee1a255c156ed569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c52a8dbbacfc52ee1a255c156ed569">&#9670;&#160;</a></span>set_hostname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_hostname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set hostname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname string </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if hostname is not valid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_BUSY</td><td>if hostname couldn't be set (e.g. for LwIP stack, hostname can only be set before calling <code><a class="el" href="class_e_m_a_c_interface.html#a2fa37e6a20d89bf8bdc2b4718bcd7cc7" title="Connect to a network.">EthernetInterface::connect</a></code> method) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#ac8f60357d89afbf207326ae062a32f68">EMACInterface</a>.</p>

</div>
</div>
<a id="a526802de6e27e291d46e3e3e6a396978" name="a526802de6e27e291d46e3e3e6a396978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526802de6e27e291d46e3e3e6a396978">&#9670;&#160;</a></span>set_mac_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_mac_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the MAC address to the interface. </p>
<p>Set the provided MAC address on the network interface. The address must be unique globally. The address must be set before calling the interface <a class="el" href="class_e_s_p32_interface.html#a8e3eb3944219908ecdae29dfaea47656" title="Attempt to connect to a Wi-Fi network.">connect()</a> method.</p>
<p>Not all interfaces are supporting MAC address set and an error is not returned for this method call. Verify the changed MAC address by checking packet captures from the used network interface.</p>
<p>6-byte EUI-48 MAC addresses are used for Ethernet while Mesh interface is using 8-byte EUI-64 address.</p>
<p>More information about obtaining MAC address can be found from: <a href="https://standards.ieee.org/products-services/regauth/index.html">https://standards.ieee.org/products-services/regauth/index.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mac_addr</td><td>Buffer containing the MAC address in hexadecimal format. </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of provided buffer in bytes (6 or 8) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if address is not valid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_BUSY</td><td>if address can't be set. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_interface_nanostack.html#a1818a2ba00bb112906e17a78c79a8c3c">InterfaceNanostack</a>, and <a class="el" href="class_e_m_a_c_interface.html#a1818a2ba00bb112906e17a78c79a8c3c">EMACInterface</a>.</p>

</div>
</div>
<a id="a77de8d1afa4b83dd6f560dc39251e1eb" name="a77de8d1afa4b83dd6f560dc39251e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77de8d1afa4b83dd6f560dc39251e1eb">&#9670;&#160;</a></span>get_ipv6_link_local_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ipv6_link_local_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the IPv6 link local address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the link local IPv6 address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a26e81e7450d1d68c4608209f565370cc">EMACInterface</a>.</p>

</div>
</div>
<a id="a241ab3896730d179348de54e86dcd36c" name="a241ab3896730d179348de54e86dcd36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241ab3896730d179348de54e86dcd36c">&#9670;&#160;</a></span>get_interface_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char * get_interface_name </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>interface_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the network interface name. </p>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated representation of the network interface name or null if interface not exists </dd></dl>

<p>Reimplemented in <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a241ab3896730d179348de54e86dcd36c">AT_CellularContext</a>, <a class="el" href="class_e_m_a_c_interface.html#a1228bd8a05b0645ecccc4dce3b0143b8">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#a1228bd8a05b0645ecccc4dce3b0143b8">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#a1228bd8a05b0645ecccc4dce3b0143b8">PPPInterface</a>.</p>

</div>
</div>
<a id="a87a975b9ef736cef63334895c5770660" name="a87a975b9ef736cef63334895c5770660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a975b9ef736cef63334895c5770660">&#9670;&#160;</a></span>getaddrinfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to the multiple IP addresses with specific version using network interface name. </p>
<p>The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> array to store the result.. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of results on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a4e2299044fa2bbb37717a7661bb608f7">DNS</a>.</p>

</div>
</div>
<a id="ab43b64cae1f145615db7f697d34552d7" name="ab43b64cae1f145615db7f697d34552d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43b64cae1f145615db7f697d34552d7">&#9670;&#160;</a></span>gethostbyname_async() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> gethostbyname_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to an IP address (asynchronous) using network interface name. </p>
<p>The hostname may be either a domain name or a dotted IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p>Call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#aede5e7d96c7b2141f60a9fefec11e462">DNS</a>.</p>

</div>
</div>
<a id="aa964732e6c585b596adc760fe95f40f5" name="aa964732e6c585b596adc760fe95f40f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa964732e6c585b596adc760fe95f40f5">&#9670;&#160;</a></span>getaddrinfo_async() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to the multiple IP addresses (asynchronous) using network interface name. </p>
<p>The hostname may be either a domain name or a dotted IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p>Call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#afd29392442faa47f202cd69ede31dd03">DNS</a>.</p>

</div>
</div>
<a id="a26000e958701f5b35886fac1757c0bf4" name="a26000e958701f5b35886fac1757c0bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26000e958701f5b35886fac1757c0bf4">&#9670;&#160;</a></span>gethostbyname_async_cancel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname_async_cancel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel asynchronous hostname translation. </p>
<p>When translation is cancelled, callback will not be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique id of the hostname translation operation (returned by gethostbyname_async) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a3ba06c19476ec03988c7cd7807823d63">DNS</a>.</p>

</div>
</div>
<a id="a0ccb0f7a5af95e76d0dea335ab866047" name="a0ccb0f7a5af95e76d0dea335ab866047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccb0f7a5af95e76d0dea335ab866047">&#9670;&#160;</a></span>get_dns_server() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_dns_server </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a domain name server from a list of servers to query. </p>
<p>Returns a <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server address for a index. If returns error no more <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> servers to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server, starts from zero </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the host address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

</div>
</div>
<a id="ab61fc4dcb3f255e327c189325eee1e43" name="ab61fc4dcb3f255e327c189325eee1e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61fc4dcb3f255e327c189325eee1e43">&#9670;&#160;</a></span>add_event_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add_event_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt;&#160;</td>
          <td class="paramname"><em>status_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add event listener for interface. </p>
<p>This API allows multiple callback to be registered for a single interface. When first called, internal list of event handlers are created and registered to interface through <a class="el" href="class_e_s_p32_interface.html#a91f2033b4f0a88ffc36eb43c11f3dba6" title="Register callback for status reporting.">attach()</a> API.</p>
<p>Application may only use <a class="el" href="class_e_s_p32_interface.html#a91f2033b4f0a88ffc36eb43c11f3dba6" title="Register callback for status reporting.">attach()</a> or <a class="el" href="class_network_interface.html#ab61fc4dcb3f255e327c189325eee1e43" title="Add event listener for interface.">add_event_listener()</a> interface. Mixing usage of both leads to undefined behavior.</p>
<dl class="section warning"><dt>Warning</dt><dd>This version of the function does not use the <code>std::nothrow</code> feature. Subsequently, the function may fail to allocate memory and cause a system error. To use the new version with the changes, set "nsapi.add-event-listener-return-change": 1 in the target overrides section in your mbed_app.json file.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_cb</td><td>The callback for status changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dc0651d23c76c830d241236e22f0a1b" name="a8dc0651d23c76c830d241236e22f0a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc0651d23c76c830d241236e22f0a1b">&#9670;&#160;</a></span>set_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set asynchronous operation of <a class="el" href="class_e_s_p32_interface.html#a8e3eb3944219908ecdae29dfaea47656" title="Attempt to connect to a Wi-Fi network.">connect()</a> and <a class="el" href="class_e_s_p32_interface.html#acd5b7c7b173b315e777e384245ca2a13" title="Stop the interface.">disconnect()</a> calls. </p>
<p>By default, interfaces are in synchronous mode which means that <a class="el" href="class_e_s_p32_interface.html#a8e3eb3944219908ecdae29dfaea47656" title="Attempt to connect to a Wi-Fi network.">connect()</a> or <a class="el" href="class_e_s_p32_interface.html#acd5b7c7b173b315e777e384245ca2a13" title="Stop the interface.">disconnect()</a> blocks until it reach the target state or requested operation fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking</td><td>Use false to set <a class="el" href="class_network_interface.html" title="Common interface that is shared between network devices.">NetworkInterface</a> in asynchronous mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success </dd>
<dd>
NSAPI_ERROR_UNSUPPORTED if driver does not support asynchronous mode. </dd>
<dd>
negative error code on failure. </dd></dl>

<p>Reimplemented in <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a8dc0651d23c76c830d241236e22f0a1b">AT_CellularContext</a>, <a class="el" href="class_interface_nanostack.html#ac1d0593b3294d27a16a956d96b09d4e2">InterfaceNanostack</a>, <a class="el" href="class_e_m_a_c_interface.html#ac1d0593b3294d27a16a956d96b09d4e2">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#ac1d0593b3294d27a16a956d96b09d4e2">L3IPInterface</a>, <a class="el" href="class_p_p_p_interface.html#ac1d0593b3294d27a16a956d96b09d4e2">PPPInterface</a>, and <a class="el" href="classmbed_1_1_cellular_context.html#ae5f6827ba6e75a5d7653fa23933ba31c">CellularContext</a>.</p>

</div>
</div>
<a id="ad3fb296eec26bfad22eb94c71c9c502d" name="ad3fb296eec26bfad22eb94c71c9c502d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fb296eec26bfad22eb94c71c9c502d">&#9670;&#160;</a></span>ethInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_eth_interface.html">EthInterface</a> * ethInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to an <a class="el" href="class_eth_interface.html" title="Common interface between Ethernet hardware.">EthInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_eth_interface.html#a66f1410ed4de66447d3364907abb9094">EthInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00463">463</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="a65c1b846fba9d9008dafa54b31d4e1a0" name="a65c1b846fba9d9008dafa54b31d4e1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c1b846fba9d9008dafa54b31d4e1a0">&#9670;&#160;</a></span>meshInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_mesh_interface.html">MeshInterface</a> * meshInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_mesh_interface.html" title="Common interface that is shared between mesh hardware.">MeshInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_mesh_interface.html#a1a5135a4e8f7628515bae7599da85269">MeshInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00479">479</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="ada0ecf739088a765ebc7fbc4181bb375" name="ada0ecf739088a765ebc7fbc4181bb375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0ecf739088a765ebc7fbc4181bb375">&#9670;&#160;</a></span>emacInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_e_m_a_c_interface.html">EMACInterface</a> * emacInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to an <a class="el" href="class_e_m_a_c_interface.html" title="EMACInterface class Implementation of the NetworkInterface for an EMAC-based driver.">EMACInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a19fdf1bbd64f27f8189ee586d1f5df24">EMACInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00487">487</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="aed55ca6584533439ab78cfd487a2c56f" name="aed55ca6584533439ab78cfd487a2c56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed55ca6584533439ab78cfd487a2c56f">&#9670;&#160;</a></span>cellularInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_cellular_interface.html">CellularInterface</a> * cellularInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_cellular_interface.html" title="Common interface that is shared between cellular interfaces.">CellularInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_cellular_interface.html#ab345524a30c3c408d28ac5abc64a24c8">CellularInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00495">495</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_e_s_p32_interface.html">ESP32Interface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
